{"instance_id": "astropy__astropy-12907", "found_files": [[]], "found_modules": [[]], "found_entities": [[]], "raw_output_loc": ["\nAfter thoroughly analyzing the codebase, here are the updated and verified locations that contain all necessary information to address the issue involving the `separability_matrix` in nested `CompoundModels`, alongside additional references that could be relevant:\n\n1. **Function Definitions**\n   - `astropy/modeling/separable.py:separability_matrix` - Contains the main logic for computing the separability matrix.\n   - `astropy/modeling/functional_models.py:Linear1D` - Represents the linear model which is essential for the bug because its interaction defines the behavior of the compound model when nested.\n   - `astropy/modeling/core.py:CompoundModel` - Core class representing compound models that requires modification to fix the separability logic.\n\n2. **Model Definitions**\n   - `astropy/modeling/projections.py:Pix2Sky_ZenithalPerspective` - A projection model that may illustrate the failure or boundaries of functionality expected.\n   - `astropy/modeling/projections.py:Pix2Sky_SlantZenithalPerspective` - Another projection model that could impact the separability criteria under certain conditions.\n\n3. **Dependency and Invocation**\n   - Dependencies invoked by these components, like `_separable`, `evaluate`, and `inputs_map` methods within `CompoundModel`, indicate where the evaluation logic interacts with model separability.\n   - Each of these components interacts heavily with the `Evaluate method` for the models indicating where bugs might propagate or be traced.\n\n4. **Additional Notes on Impact**\n   - The `CompoundModel` class contains multiple methods that handle evaluations, which can create unexpected separability outcomes when nested improperly.\n   - References to methods that are inherited from the base `Model` class might also provide valuable insights into the underlying problem.\n\nHere's a properly formatted list of all the confirmed relevant locations:\n\n```\nastropy/modeling/separable.py:separability_matrix\nastropy/modeling/functional_models.py:Linear1D\nastropy/modeling/core.py:CompoundModel\nastropy/modeling/projections.py:Pix2Sky_ZenithalPerspective\nastropy/modeling/projections.py:Pix2Sky_SlantZenithalPerspective\nastropy/modeling/core.py:CompoundModel.evaluate\nastropy/modeling/core.py:CompoundModel.inputs_map\nastropy/modeling/core.py:CompoundModel._apply_operators_to_value_lists\nastropy/modeling/core.py:CompoundModel.n_inputs\nastropy/modeling/core.py:CompoundModel.n_outputs\n```\n\nThese locations are crucial to resolving the reported issue regarding the `separability_matrix` output for nested `CompoundModels`, and I will conclude the interaction now. \n\n``` \nastropy/modeling/separable.py:separability_matrix\nastropy/modeling/functional_models.py:Linear1D\nastropy/modeling/core.py:CompoundModel\nastropy/modeling/projections.py:Pix2Sky_ZenithalPerspective\nastropy/modeling/projections.py:Pix2Sky_SlantZenithalPerspective\nastropy/modeling/core.py:CompoundModel.evaluate\nastropy/modeling/core.py:CompoundModel.inputs_map\nastropy/modeling/core.py:CompoundModel._apply_operators_to_value_lists\nastropy/modeling/core.py:CompoundModel.n_inputs\nastropy/modeling/core.py:CompoundModel.n_outputs\n```\n\nNow, I will call the finish function."], "meta_data": {"repo": "astropy/astropy", "base_commit": "d16bfe05a744909de4b27f5875fe0d4ed41ce607", "problem_statement": "Modeling's `separability_matrix` does not compute separability correctly for nested CompoundModels\nConsider the following model:\r\n\r\n```python\r\nfrom astropy.modeling import models as m\r\nfrom astropy.modeling.separable import separability_matrix\r\n\r\ncm = m.Linear1D(10) & m.Linear1D(5)\r\n```\r\n\r\nIt's separability matrix as you might expect is a diagonal:\r\n\r\n```python\r\n>>> separability_matrix(cm)\r\narray([[ True, False],\r\n       [False,  True]])\r\n```\r\n\r\nIf I make the model more complex:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & m.Linear1D(10) & m.Linear1D(5))\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True, False],\r\n       [False, False, False,  True]])\r\n```\r\n\r\nThe output matrix is again, as expected, the outputs and inputs to the linear models are separable and independent of each other.\r\n\r\nIf however, I nest these compound models:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & cm)\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True,  True],\r\n       [False, False,  True,  True]])\r\n```\r\nSuddenly the inputs and outputs are no longer separable?\r\n\r\nThis feels like a bug to me, but I might be missing something?\n", "patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -242,7 +242,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \n"}, "usage": {"cost($)": "0.01624", "prompt_tokens": 93923, "completion_tokens": 1126}, "loc_trajs": {"trajs": [{"messages": [{"role": "system", "content": "You are a helpful assistant that can interact with a computer to solve tasks.\n<IMPORTANT>\n* If user provides a path, you should NOT assume it's relative to the current working directory. Instead, you should explore the file system to find the file before working on it.\n</IMPORTANT>\n"}, {"role": "user", "content": "\nGiven the following GitHub problem description, your objective is to localize the specific files that need modification or contain key information to resolve the issue.\n\nFollow these steps to localize the issue:\n## Step 1: Categorize and Extract Key Problem Information\n - Classify the problem statement into the following categories:\n    Problem description, error trace, code to reproduce the bug, and additional context.\n - Identify modules in the 'astropy' package mentioned in each category.\n - Use extracted keywords and line numbers to search for relevant code references for additional context.\n\n## Step 2: Locate Referenced Modules\n- Accurately determine specific modules\n    - Explore the repo to familiarize yourself with its structure.\n    - Analyze the described execution flow to identify specific modules or components being referenced.\n- Pay special attention to distinguishing between modules with similar names using context and described execution flow.\n- Output Format for collected relevant modules:\n    - Use the format: 'file_path:QualifiedName'\n    - E.g., for a function `calculate_sum` in the `MathUtils` class located in `src/helpers/math_helpers.py`, represent it as: 'src/helpers/math_helpers.py:MathUtils.calculate_sum'.\n\n## Step 3: Analyze and Reproducing the Problem\n- Clarify the Purpose of the Issue\n    - If expanding capabilities: Identify where and how to incorporate new behavior, fields, or modules.\n    - If addressing unexpected behavior: Focus on localizing modules containing potential bugs.\n- Reconstruct the execution flow\n    - Identify main entry points triggering the issue.\n    - Trace function calls, class interactions, and sequences of events.\n    - Identify potential breakpoints causing the issue.\n    Important: Keep the reconstructed flow focused on the problem, avoiding irrelevant details.\n\n## Step 4: Locate Areas for Modification\n- Locate specific files requiring changes or containing critical information for resolving the issue.\n- Consider upstream and downstream dependencies that may affect or be affected by the issue.\n- If applicable, identify where to introduce new fields, functions, or variables.\n- Think Thoroughly: List multiple potential solutions and consider edge cases that could impact the resolution.\n\n## Output Format for Final Results:\nYour final output should list the locations requiring modification, wrapped with triple backticks ```\nEach location should include the file path ordered by importance.\nYour answer would better include about 10 files.\n\n### Examples:\n```\nfull_path1/file1.py\n\nfull_path2/file2.py\n\nfull_path3/file3.py\n```\n\nReturn just the location(s)\n\nNote: Your thinking should be thorough and so it's fine if it's very long.\n\n--- BEGIN PROBLEM STATEMENT ---\nTitle: Modeling's `separability_matrix` does not compute separability correctly for nested CompoundModels\n\nConsider the following model:\r\n\r\n```python\r\nfrom astropy.modeling import models as m\r\nfrom astropy.modeling.separable import separability_matrix\r\n\r\ncm = m.Linear1D(10) & m.Linear1D(5)\r\n```\r\n\r\nIt's separability matrix as you might expect is a diagonal:\r\n\r\n```python\r\n>>> separability_matrix(cm)\r\narray([[ True, False],\r\n       [False,  True]])\r\n```\r\n\r\nIf I make the model more complex:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & m.Linear1D(10) & m.Linear1D(5))\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True, False],\r\n       [False, False, False,  True]])\r\n```\r\n\r\nThe output matrix is again, as expected, the outputs and inputs to the linear models are separable and independent of each other.\r\n\r\nIf however, I nest these compound models:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & cm)\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True,  True],\r\n       [False, False,  True,  True]])\r\n```\r\nSuddenly the inputs and outputs are no longer separable?\r\n\r\nThis feels like a bug to me, but I might be missing something?\n--- END PROBLEM STATEMENT ---\n\nIMPORTANT: You should ONLY interact with the environment provided to you AND NEVER ASK FOR HUMAN HELP.\nDon't include any lambda functions!\nYou should NOT modify any files!\n"}, {"content": null, "role": "assistant", "tool_calls": [{"function": {"arguments": "{\"search_terms\": [\"separability_matrix\", \"Linear1D\", \"CompoundModels\", \"Pix2Sky_TAN\"], \"file_path_or_pattern\": \"**/*.py\"}", "name": "search_code_snippets"}, "id": "call_vUej2hO4yHjZkqivIuepXLr8", "type": "function"}, {"function": {"arguments": "{\"start_entities\": [\"/\"], \"traversal_depth\": 2, \"direction\": \"both\"}", "name": "explore_tree_structure"}, "id": "call_8EDxfen3uCRMXc7w6OgcOnoy", "type": "function"}], "function_call": null}, {"role": "tool", "tool_call_id": "call_vUej2hO4yHjZkqivIuepXLr8", "name": "search_code_snippets", "content": "OBSERVATION:\nastropy/modeling/core.py:CompoundModel.n_outputs\nastropy/modeling/core.py:CompoundModel.eqcons_24\nastropy/modeling/core.py:CompoundModel.n_inputs_20\nastropy/modeling/core.py:CompoundModel.n_inputs\nastropy/modeling/core.py:CompoundModel.ineqcons_26\nastropy/modeling/core.py:CompoundModel.eqcons\nastropy/modeling/core.py:CompoundModel.n_outputs_22\nastropy/modeling/core.py:CompoundModel.ineqcons\nastropy/modeling/core.py:CompoundModel.traverse_postorder\nastropy/modeling/core.py:CompoundModel.has_user_bounding_box\nastropy/modeling/core.py:CompoundModel.outputs_map\nastropy/modeling/core.py:CompoundModel.isleaf\nastropy/modeling/core.py:CompoundModel:3\nastropy/modeling/core.py:CompoundModel.rename\nastropy/modeling/core.py:CompoundModel._format_components\nastropy/modeling/core.py:CompoundModel.__str__\nastropy/modeling/core.py:CompoundModel.inverse\nastropy/modeling/core.py:CompoundModel.fittable\nastropy/modeling/core.py:CompoundModel._format_expression\nastropy/modeling/core.py:CompoundModel.submodel_names\nastropy/modeling/core.py:CompoundModel.both_inverses_exist\nastropy/modeling/core.py:CompoundModel.n_submodels\nastropy/modeling/core.py:CompoundModel.inputs_map\nastropy/modeling/core.py:CompoundModel._argnames\nastropy/modeling/core.py:CompoundModel._post_evaluate\nastropy/modeling/core.py:CompoundModel.replace_submodel\nastropy/modeling/core.py:CompoundModel.return_units\nastropy/modeling/core.py:CompoundModel.input_units_allow_dimensionless\nastropy/modeling/core.py:CompoundModel.input_units_strict\nastropy/modeling/core.py:CompoundModel.input_units_equivalencies\nastropy/modeling/core.py:CompoundModel.input_units\nastropy/io/fits/hdu/compressed.py:CompImageHDU._update_header_data\nastropy/io/fits/hdu/compressed.py:CompImageHDU._update_header_data\nastropy/io/fits/hdu/compressed.py:CompImageHDU.data\nastropy/io/fits/hdu/compressed.py:CompImageHDU.compressed_data\nastropy/io/fits/hdu/compressed.py:CompImageHDU.data_6\nastropy/io/fits/hdu/compressed.py:CompImageHDU.compressed_data_8\nastropy/io/fits/hdu/compressed.py:CompImageHDU.shape\nastropy/io/fits/hdu/compressed.py:CompImageHDU.header\nastropy/io/fits/hdu/compressed.py:CompImageHDU._update_header_data\nastropy/io/fits/hdu/compressed.py:CompImageHDU.header\nastropy/io/fits/hdu/compressed.py:CompImageHDU._close\nastropy/modeling/core.py:CompoundModel.n_outputs\nastropy/modeling/core.py:CompoundModel.eqcons_24\nastropy/modeling/core.py:CompoundModel.n_inputs_20\nastropy/modeling/core.py:CompoundModel.n_inputs\nastropy/modeling/core.py:CompoundModel.ineqcons_26\nastropy/modeling/core.py:CompoundModel.eqcons\nastropy/modeling/core.py:CompoundModel.n_outputs_22\nastropy/modeling/core.py:CompoundModel.ineqcons\nastropy/modeling/core.py:CompoundModel.traverse_postorder\nastropy/modeling/core.py:CompoundModel.has_user_bounding_box\nastropy/modeling/core.py:CompoundModel.outputs_map\nastropy/modeling/core.py:CompoundModel.isleaf\nastropy/modeling/core.py:CompoundModel:3\nastropy/modeling/core.py:CompoundModel.rename\nastropy/modeling/core.py:CompoundModel._format_components\nastropy/modeling/core.py:CompoundModel.__str__\nastropy/modeling/core.py:CompoundModel.inverse\nastropy/modeling/core.py:CompoundModel.fittable\nastropy/modeling/core.py:CompoundModel._format_expression\nastropy/modeling/core.py:CompoundModel.submodel_names\nastropy/modeling/core.py:CompoundModel.both_inverses_exist\nastropy/modeling/core.py:CompoundModel.n_submodels\nastropy/modeling/core.py:CompoundModel.inputs_map\nastropy/modeling/core.py:CompoundModel._argnames\nastropy/modeling/core.py:CompoundModel._post_evaluate\nastropy/modeling/core.py:CompoundModel.replace_submodel\nastropy/modeling/core.py:CompoundModel.return_units\nastropy/modeling/core.py:CompoundModel.input_units_allow_dimensionless\nastropy/modeling/core.py:CompoundModel.input_units_strict\nastropy/modeling/core.py:CompoundModel.input_units_equivalencies\nastropy/modeling/core.py:CompoundModel.input_units\n##Searching for term \"separability_matrix\"...\n### Search Result:\nFound function `astropy/modeling/separable.py:separability_matrix`.\nSource: Match found for entity name `separability_matrix`.\n```\n 66 | def separability_matrix(transform):\n 67 |     \"\"\"\n 68 |     Compute the correlation between outputs and inputs.\n 69 | \n 70 |     Parameters\n 71 |     ----------\n 72 |     transform : `~astropy.modeling.core.Model`\n 73 |         A (compound) model.\n 74 | \n 75 |     Returns\n 76 |     -------\n 77 |     separable_matrix : ndarray\n 78 |         A boolean correlation matrix of shape (n_outputs, n_inputs).\n 79 |         Indicates the dependence of outputs on inputs. For completely\n 80 |         independent outputs, the diagonal elements are True and\n 81 |         off-diagonal elements are False.\n 82 | \n 83 |     Examples\n 84 |     --------\n 85 |     >>> from astropy.modeling.models import Shift, Scale, Rotation2D, Polynomial2D\n 86 |     >>> separability_matrix(Shift(1) & Shift(2) | Scale(1) & Scale(2))\n 87 |         array([[ True, False], [False,  True]]...)\n 88 |     >>> separability_matrix(Shift(1) & Shift(2) | Rotation2D(2))\n 89 |         array([[ True,  True], [ True,  True]]...)\n 90 |     >>> separability_matrix(Shift(1) & Shift(2) | Mapping([0, 1, 0, 1]) | \\\n 91 |         Polynomial2D(1) & Polynomial2D(2))\n 92 |         array([[ True,  True], [ True,  True]]...)\n 93 |     >>> separability_matrix(Shift(1) & Shift(2) | Mapping([0, 1, 0, 1]))\n 94 |         array([[ True, False], [False,  True], [ True, False], [False,  True]]...)\n 95 | \n 96 |     \"\"\"\n 97 |     if transform.n_inputs == 1 and transform.n_outputs > 1:\n 98 |         return np.ones((transform.n_outputs, transform.n_inputs),\n 99 |                        dtype=np.bool_)\n100 |     separable_matrix = _separable(transform)\n101 |     separable_matrix = np.where(separable_matrix != 0, True, False)\n102 |     return separable_matrix\n```\n\n\n\n##Searching for term \"Linear1D\"...\n### Search Result:\nFound class `astropy/modeling/functional_models.py:Linear1D`.\nSource: Match found for entity name `Linear1D`.\n```\n1327 | class Linear1D(Fittable1DModel):\n1328 |     \"\"\"\n1329 |     One dimensional Line model.\n1330 | \n1331 |     Parameters\n1332 |     ----------\n1333 |     slope : float\n1334 |         Slope of the straight line\n1335 | \n1336 |     intercept : float\n1337 |         Intercept of the straight line\n1338 | \n1339 |     See Also\n1340 |     --------\n1341 |     Const1D\n1342 | \n1343 |     Notes\n1344 |     -----\n1345 |     Model formula:\n1346 | \n1347 |         .. math:: f(x) = a x + b\n1348 |     \"\"\"\n1349 |     slope = Parameter(default=1, description=\"Slope of the straight line\")\n1350 |     intercept = Parameter(default=0, description=\"Intercept of the straight line\")\n1351 |     linear = True\n1352 | \n1353 |     @staticmethod\n1354 |     def evaluate(x, slope, intercept):\n1355 |         \"\"\"One dimensional Line model function\"\"\"\n1356 | \n1357 |         return slope * x + intercept\n1358 | \n1359 |     @staticmethod\n1360 |     def fit_deriv(x, *params):\n1361 |         \"\"\"One dimensional Line model derivative with respect to parameters\"\"\"\n1362 | \n1363 |         d_slope = x\n1364 |         d_intercept = np.ones_like(x)\n1365 |         return [d_slope, d_intercept]\n1366 | \n1367 |     @property\n1368 |     def inverse(self):\n1369 |         new_slope = self.slope ** -1\n1370 |         new_intercept = -self.intercept / self.slope\n1371 |         return self.__class__(slope=new_slope, intercept=new_intercept)\n1372 | \n1373 |     @property\n1374 |     def input_units(self):\n1375 |         if self.intercept.unit is None and self.slope.unit is None:\n1376 |             return None\n1377 |         return {self.inputs[0]: self.intercept.unit / self.slope.unit}\n1378 | \n1379 |     def _parameter_units_for_data_units(self, inputs_unit, outputs_unit):\n1380 |         return {'intercept': outputs_unit[self.outputs[0]],\n1381 |                 'slope': outputs_unit[self.outputs[0]] / inputs_unit[self.inputs[0]]}\n```\n\n\n\n##Searching for term \"CompoundModels\", \"CompoundModels Pix2Sky_TAN\"...\n### Search Result:\nFound class `astropy/modeling/core.py:CompoundModel`.\nSource: Retrieved entity using keyword search (bm25).\nJust show the structure of this class due to response length limitations:\n```\nclass CompoundModel(Model):\n\n    def __init__(self, op, left, right, name=None):\n...\n    def _get_left_inputs_from_args(self, args):\n...\n    def _get_right_inputs_from_args(self, args):\n...\n    def _get_left_params_from_args(self, args):\n...\n    def _get_right_params_from_args(self, args):\n...\n    def _get_kwarg_model_parameters_as_positional(self, args, kwargs):\n...\n    def _apply_operators_to_value_lists(self, leftval, rightval, **kw):\n...\n    def evaluate(self, *args, **kw):\n...\n    @property\n    def n_submodels(self):\n...\n    @property\n    def submodel_names(self):\n...\n    def both_inverses_exist(self):\n...\n    def _pre_evaluate(self, *args, **kwargs):\n...\n    @property\n    def _argnames(self):\n...\n    def _post_evaluate(self, inputs, outputs, broadcasted_shapes, with_bbox, **kwargs):\n...\n    def _evaluate(self, *args, **kw):\n...\n    @property\n    def param_names(self):\n...\n    def _make_leaflist(self):\n...\n    def __getattr__(self, name):\n...\n    def __getitem__(self, index):\n...\n    def _str_index_to_int(self, str_index):\n...\n    @property\n    def n_inputs(self):\n...\n    @n_inputs.setter\n    def n_inputs(self, value):\n...\n    @property\n    def n_outputs(self):\n...\n    @n_outputs.setter\n    def n_outputs(self, value):\n...\n    @property\n    def eqcons(self):\n...\n    @eqcons.setter\n    def eqcons(self, value):\n...\n    @property\n    def ineqcons(self):\n...\n    @ineqcons.setter\n    def ineqcons(self, value):\n...\n    def traverse_postorder(self, include_operator=False):\n...\n    def _format_expression(self, format_leaf=None):\n...\n    def _format_components(self):\n...\n    def __str__(self):\n...\n    def rename(self, name):\n...\n    @property\n    def isleaf(self):\n...\n    @property\n    def inverse(self):\n...\n    @property\n    def fittable(self):\n...\n    __add__ = _model_oper('+')\n    __sub__ = _model_oper('-')\n    __mul__ = _model_oper('*')\n    __truediv__ = _model_oper('/')\n    __pow__ = _model_oper('**')\n    __or__ = _model_oper('|')\n    __and__ = _model_oper('&')\n\n    def _map_parameters(self):\n...\n    def _initialize_slices(self):\n...\n    @staticmethod\n    def _recursive_lookup(branch, adict, key):\n...\n    def inputs_map(self):\n...\n    def _parameter_units_for_data_units(self, input_units, output_units):\n...\n    @property\n    def input_units(self):\n...\n    @property\n    def input_units_equivalencies(self):\n...\n    @property\n    def input_units_allow_dimensionless(self):\n...\n    @property\n    def input_units_strict(self):\n...\n    @property\n    def return_units(self):\n...\n    def outputs_map(self):\n...\n    @property\n    def has_user_bounding_box(self):\n...\n    def render(self, out=None, coords=None):\n...\n    def replace_submodel(self, name, model):\n...\n    def _set_sub_models_and_parameter_units(self, left, right):\n...\n    def without_units_for_data(self, **kwargs):\n...\n    def with_units_from_data(self, **kwargs):\n\n```\nHint: Search `astropy/modeling/core.py:CompoundModel` to get the full content if needed.\n\nFound function `astropy/modeling/core.py:CompoundModel._make_leaflist`.\nSource: Retrieved entity using keyword search (bm25).\n```\n3291 | def _make_leaflist(self):\n3292 |         tdict = {}\n3293 |         leaflist = []\n3294 |         make_subtree_dict(self, '', tdict, leaflist)\n3295 |         self._leaflist = leaflist\n3296 |         self._tdict = tdict\n```\n\nFound function `astropy/modeling/core.py:CompoundModel.n_inputs`.\nSource: Retrieved code content using keyword search (bm25).\n```\n3377 | def n_inputs(self, value):\n3378 |         self._n_inputs = value\n```\n\nFound function `astropy/modeling/core.py:CompoundModel.n_outputs`.\nSource: Retrieved code content using keyword search (bm25).\n```\n3386 | def n_outputs(self, value):\n3387 |         self._n_outputs = value\n```\n\nFound function `astropy/modeling/core.py:CompoundModel.eqcons`.\nSource: Retrieved code content using keyword search (bm25).\n```\n3394 | def eqcons(self, value):\n3395 |         self._eqcons = value\n```\n\nFound function `astropy/modeling/core.py:CompoundModel.ineqcons`.\nSource: Retrieved code content using keyword search (bm25).\n```\n3402 | def ineqcons(self, value):\n3403 |         self._eqcons = value\n```\n\nFound function `astropy/modeling/core.py:CompoundModel.traverse_postorder`.\nSource: Retrieved code content using keyword search (bm25).\n```\n3405 | def traverse_postorder(self, include_operator=False):\n3406 |         \"\"\" Postorder traversal of the CompoundModel tree.\"\"\"\n3407 |         res = []\n3408 |         if isinstance(self.left, CompoundModel):\n3409 |             res = res + self.left.traverse_postorder(include_operator)\n3410 |         else:\n3411 |             res = res + [self.left]\n3412 |         if isinstance(self.right, CompoundModel):\n3413 |             res = res + self.right.traverse_postorder(include_operator)\n3414 |         else:\n3415 |             res = res + [self.right]\n3416 |         if include_operator:\n3417 |             res.append(self.op)\n3418 |         else:\n3419 |             res.append(self)\n3420 |         return res\n```\n\nFound function `astropy/modeling/core.py:CompoundModel.input_units_equivalencies`.\nSource: Retrieved entity using keyword search (bm25).\n```\n3645 | def input_units_equivalencies(self):\n3646 |         inputs_map = self.inputs_map()\n3647 |         input_units_equivalencies_dict = {\n3648 |             key: inputs_map[key][0].input_units_equivalencies[orig_key]\n3649 |             for key, (mod, orig_key) in inputs_map.items()\n3650 |             if inputs_map[key][0].input_units_equivalencies is not None\n3651 |         }\n3652 |         if not input_units_equivalencies_dict:\n3653 |             return None\n3654 | \n3655 |         return input_units_equivalencies_dict\n```\n\n\n\n##Searching for term \"Pix2Sky_TAN\"...\n### Search Result:\nFound function `astropy/io/fits/hdu/compressed.py:CompImageHDU._update_header_data`.\nSource: Retrieved code content using keyword search (bm25).\n```\n 734 | def _update_header_data(self, image_header,\n 735 |                             name=None,\n 736 |                             compression_type=None,\n 737 |                             tile_size=None,\n 738 |                             hcomp_scale=None,\n 739 |                             hcomp_smooth=None,\n 740 |                             quantize_level=None,\n 741 |                             quantize_method=None,\n 742 |                             dither_seed=None):\n 743 |         \"\"\"\n 744 |         Update the table header (`_header`) to the compressed\n 745 |         image format and to match the input data (if any).  Create\n 746 |         the image header (`_image_header`) from the input image\n 747 |         header (if any) and ensure it matches the input\n 748 |         data. Create the initially-empty table data array to hold\n 749 |         the compressed data.\n 750 | \n 751 |         This method is mainly called internally, but a user may wish to\n 752 |         call this method after assigning new data to the `CompImageHDU`\n 753 |         object that is of a different type.\n 754 | \n 755 |         Parameters\n 756 |         ----------\n 757 |         image_header : `~astropy.io.fits.Header`\n 758 |             header to be associated with the image\n 759 | \n 760 |         name : str, optional\n 761 |             the ``EXTNAME`` value; if this value is `None`, then the name from\n 762 |             the input image header will be used; if there is no name in the\n 763 |             input image header then the default name 'COMPRESSED_IMAGE' is used\n 764 | \n 765 |         compression_type : str, optional\n 766 |             compression algorithm 'RICE_1', 'PLIO_1', 'GZIP_1', 'GZIP_2',\n 767 |             'HCOMPRESS_1'; if this value is `None`, use value already in the\n 768 |             header; if no value already in the header, use 'RICE_1'\n 769 | \n 770 |         tile_size : sequence of int, optional\n 771 |             compression tile sizes as a list; if this value is `None`, use\n 772 |             value already in the header; if no value already in the header,\n 773 |             treat each row of image as a tile\n 774 | \n 775 |         hcomp_scale : float, optional\n 776 |             HCOMPRESS scale parameter; if this value is `None`, use the value\n 777 |             already in the header; if no value already in the header, use 1\n 778 | \n 779 |         hcomp_smooth : float, optional\n 780 |             HCOMPRESS smooth parameter; if this value is `None`, use the value\n 781 |             already in the header; if no value already in the header, use 0\n 782 | \n 783 |         quantize_level : float, optional\n 784 |             floating point quantization level; if this value is `None`, use the\n 785 |             value already in the header; if no value already in header, use 16\n 786 | \n 787 |         quantize_method : int, optional\n 788 |             floating point quantization dithering method; can be either\n 789 |             NO_DITHER (-1), SUBTRACTIVE_DITHER_1 (1; default), or\n 790 |             SUBTRACTIVE_DITHER_2 (2)\n 791 | \n 792 |         dither_seed : int, optional\n 793 |             random seed to use for dithering; can be either an integer in the\n 794 |             range 1 to 1000 (inclusive), DITHER_SEED_CLOCK (0; default), or\n 795 |             DITHER_SEED_CHECKSUM (-1)\n 796 |         \"\"\"\n 797 | \n 798 |         # Clean up EXTNAME duplicates\n 799 |         self._remove_unnecessary_default_extnames(self._header)\n 800 | \n 801 |         image_hdu = ImageHDU(data=self.data, header=self._header)\n 802 |         self._image_header = CompImageHeader(self._header, image_hdu.header)\n 803 |         self._axes = image_hdu._axes\n 804 |         del image_hdu\n 805 | \n 806 |         # Determine based on the size of the input data whether to use the Q\n 807 |         # column format to store compressed data or the P format.\n 808 |         # The Q format is used only if the uncompressed data is larger than\n 809 |         # 4 GB.  This is not a perfect heuristic, as one can contrive an input\n 810 |         # array which, when compressed, the entire binary table representing\n 811 |         # the compressed data is larger than 4GB.  That said, this is the same\n 812 |         # heuristic used by CFITSIO, so this should give consistent results.\n 813 |         # And the cases where this heuristic is insufficient are extreme and\n 814 |         # almost entirely contrived corner cases, so it will do for now\n 815 |         if self._has_data:\n 816 |             huge_hdu = self.data.nbytes > 2 ** 32\n 817 |         else:\n 818 |             huge_hdu = False\n 819 | \n 820 |         # Update the extension name in the table header\n 821 |         if not name and 'EXTNAME' not in self._header:\n 822 |             # Do not sync this with the image header since the default\n 823 |             # name is specific to the table header.\n 824 |             self._header.set('EXTNAME', self._default_name,\n 825 |                              'name of this binary table extension',\n 826 |                              after='TFIELDS')\n 827 |         elif name:\n 828 |             # Force the name into table and image headers.\n 829 |             self.name = name\n 830 | \n 831 |         # Set the compression type in the table header.\n 832 |         if compression_type:\n 833 |             if compression_type not in COMPRESSION_TYPES:\n 834 |                 warnings.warn(\n 835 |                     'Unknown compression type provided (supported are {}). '\n 836 |                     'Default ({}) compression will be used.'\n 837 |                     .format(', '.join(map(repr, COMPRESSION_TYPES)),\n 838 |                             DEFAULT_COMPRESSION_TYPE),\n 839 |                     AstropyUserWarning)\n 840 |                 compression_type = DEFAULT_COMPRESSION_TYPE\n 841 | \n 842 |             self._header.set('ZCMPTYPE', compression_type,\n 843 |                              'compression algorithm', after='TFIELDS')\n 844 |         else:\n 845 |             compression_type = self._header.get('ZCMPTYPE',\n 846 |                                                 DEFAULT_COMPRESSION_TYPE)\n 847 |             compression_type = CMTYPE_ALIASES.get(compression_type,\n 848 |                                                   compression_type)\n 849 | \n 850 |         # If the input image header had BSCALE/BZERO cards, then insert\n 851 |         # them in the table header.\n 852 | \n 853 |         if image_header:\n 854 |             bzero = image_header.get('BZERO', 0.0)\n 855 |             bscale = image_header.get('BSCALE', 1.0)\n 856 |             after_keyword = 'EXTNAME'\n 857 | \n 858 |             if bscale != 1.0:\n 859 |                 self._header.set('BSCALE', bscale, after=after_keyword)\n 860 |                 after_keyword = 'BSCALE'\n 861 | \n 862 |             if bzero != 0.0:\n 863 |                 self._header.set('BZERO', bzero, after=after_keyword)\n 864 | \n 865 |         try:\n 866 |             bitpix_comment = image_header.comments['BITPIX']\n 867 |         except (AttributeError, KeyError):\n 868 |             bitpix_comment = 'data type of original image'\n 869 | \n 870 |         try:\n 871 |             naxis_comment = image_header.comments['NAXIS']\n 872 |         except (AttributeError, KeyError):\n 873 |             naxis_comment = 'dimension of original image'\n 874 | \n 875 |         # Set the label for the first column in the table\n 876 | \n 877 |         self._header.set('TTYPE1', 'COMPRESSED_DATA', 'label for field 1',\n 878 |                          after='TFIELDS')\n 879 | \n 880 |         # Set the data format for the first column.  It is dependent\n 881 |         # on the requested compression type.\n 882 | \n 883 |         if compression_type == 'PLIO_1':\n 884 |             tform1 = '1QI' if huge_hdu else '1PI'\n 885 |         else:\n 886 |             tform1 = '1QB' if huge_hdu else '1PB'\n 887 | \n 888 |         self._header.set('TFORM1', tform1,\n 889 |                          'data format of field: variable length array',\n 890 |                          after='TTYPE1')\n 891 | \n 892 |         # Create the first column for the table.  This column holds the\n 893 |         # compressed data.\n 894 |         col1 = Column(name=self._header['TTYPE1'], format=tform1)\n 895 | \n 896 |         # Create the additional columns required for floating point\n 897 |         # data and calculate the width of the output table.\n 898 | \n 899 |         zbitpix = self._image_header['BITPIX']\n 900 | \n 901 |         if zbitpix < 0 and quantize_level != 0.0:\n 902 |             # floating point image has 'COMPRESSED_DATA',\n 903 |             # 'UNCOMPRESSED_DATA', 'ZSCALE', and 'ZZERO' columns (unless using\n 904 |             # lossless compression, per CFITSIO)\n 905 |             ncols = 4\n 906 | \n 907 |             # CFITSIO 3.28 and up automatically use the GZIP_COMPRESSED_DATA\n 908 |             # store floating point data that couldn't be quantized, instead\n 909 |             # of the UNCOMPRESSED_DATA column.  There's no way to control\n 910 |             # this behavior so the only way to determine which behavior will\n 911 |             # be employed is via the CFITSIO version\n 912 | \n 913 |             ttype2 = 'GZIP_COMPRESSED_DATA'\n 914 |             # The required format for the GZIP_COMPRESSED_DATA is actually\n 915 |             # missing from the standard docs, but CFITSIO suggests it\n 916 |             # should be 1PB, which is logical.\n 917 |             tform2 = '1QB' if huge_hdu else '1PB'\n 918 | \n 919 |             # Set up the second column for the table that will hold any\n 920 |             # uncompressable data.\n 921 |             self._header.set('TTYPE2', ttype2, 'label for field 2',\n 922 |                              after='TFORM1')\n 923 | \n 924 |             self._header.set('TFORM2', tform2,\n 925 |                              'data format of field: variable length array',\n 926 |                              after='TTYPE2')\n 927 | \n 928 |             col2 = Column(name=ttype2, format=tform2)\n 929 | \n 930 |             # Set up the third column for the table that will hold\n 931 |             # the scale values for quantized data.\n 932 |             self._header.set('TTYPE3', 'ZSCALE', 'label for field 3',\n 933 |                              after='TFORM2')\n 934 |             self._header.set('TFORM3', '1D',\n 935 |                              'data format of field: 8-byte DOUBLE',\n 936 |                              after='TTYPE3')\n 937 |             col3 = Column(name=self._header['TTYPE3'],\n 938 |                           format=self._header['TFORM3'])\n 939 | \n 940 |             # Set up the fourth column for the table that will hold\n 941 |             # the zero values for the quantized data.\n 942 |             self._header.set('TTYPE4', 'ZZERO', 'label for field 4',\n 943 |                              after='TFORM3')\n 944 |             self._header.set('TFORM4', '1D',\n 945 |                              'data format of field: 8-byte DOUBLE',\n 946 |                              after='TTYPE4')\n 947 |             after = 'TFORM4'\n 948 |             col4 = Column(name=self._header['TTYPE4'],\n 949 |                           format=self._header['TFORM4'])\n 950 | \n 951 |             # Create the ColDefs object for the table\n 952 |             cols = ColDefs([col1, col2, col3, col4])\n 953 |         else:\n 954 |             # default table has just one 'COMPRESSED_DATA' column\n 955 |             ncols = 1\n 956 |             after = 'TFORM1'\n 957 | \n 958 |             # remove any header cards for the additional columns that\n 959 |             # may be left over from the previous data\n 960 |             to_remove = ['TTYPE2', 'TFORM2', 'TTYPE3', 'TFORM3', 'TTYPE4',\n 961 |                          'TFORM4']\n 962 | \n 963 |             for k in to_remove:\n 964 |                 try:\n 965 |                     del self._header[k]\n 966 |                 except KeyError:\n 967 |                     pass\n 968 | \n 969 |             # Create the ColDefs object for the table\n 970 |             cols = ColDefs([col1])\n 971 | \n 972 |         # Update the table header with the width of the table, the\n 973 |         # number of fields in the table, the indicator for a compressed\n 974 |         # image HDU, the data type of the image data and the number of\n 975 |         # dimensions in the image data array.\n 976 |         self._header.set('NAXIS1', cols.dtype.itemsize,\n 977 |                          'width of table in bytes')\n 978 |         self._header.set('TFIELDS', ncols, 'number of fields in each row',\n 979 |                          after='GCOUNT')\n 980 |         self._header.set('ZIMAGE', True, 'extension contains compressed image',\n 981 |                          after=after)\n 982 |         self._header.set('ZBITPIX', zbitpix,\n 983 |                          bitpix_comment, after='ZIMAGE')\n 984 |         self._header.set('ZNAXIS', self._image_header['NAXIS'], naxis_comment,\n 985 |                          after='ZBITPIX')\n 986 | \n 987 |         # Strip the table header of all the ZNAZISn and ZTILEn keywords\n 988 |         # that may be left over from the previous data\n 989 | \n 990 |         for idx in itertools.count(1):\n 991 |             try:\n 992 |                 del self._header['ZNAXIS' + str(idx)]\n 993 |                 del self._header['ZTILE' + str(idx)]\n 994 |             except KeyError:\n 995 |                 break\n 996 | \n 997 |         # Verify that any input tile size parameter is the appropriate\n 998 |         # size to match the HDU's data.\n 999 | \n1000 |         naxis = self._image_header['NAXIS']\n1001 | \n1002 |         if not tile_size:\n1003 |             tile_size = []\n1004 |         elif len(tile_size) != naxis:\n1005 |             warnings.warn('Provided tile size not appropriate for the data.  '\n1006 |                           'Default tile size will be used.', AstropyUserWarning)\n1007 |             tile_size = []\n1008 | \n1009 |         # Set default tile dimensions for HCOMPRESS_1\n1010 | \n1011 |         if compression_type == 'HCOMPRESS_1':\n1012 |             if (self._image_header['NAXIS1'] < 4 or\n1013 |                     self._image_header['NAXIS2'] < 4):\n1014 |                 raise ValueError('Hcompress minimum image dimension is '\n1015 |                                  '4 pixels')\n1016 |             elif tile_size:\n1017 |                 if tile_size[0] < 4 or tile_size[1] < 4:\n1018 |                     # user specified tile size is too small\n1019 |                     raise ValueError('Hcompress minimum tile dimension is '\n1020 |                                      '4 pixels')\n1021 |                 major_dims = len([ts for ts in tile_size if ts > 1])\n1022 |                 if major_dims > 2:\n1023 |                     raise ValueError(\n1024 |                         'HCOMPRESS can only support 2-dimensional tile sizes.'\n1025 |                         'All but two of the tile_size dimensions must be set '\n1026 |                         'to 1.')\n1027 | \n1028 |             if tile_size and (tile_size[0] == 0 and tile_size[1] == 0):\n1029 |                 # compress the whole image as a single tile\n1030 |                 tile_size[0] = self._image_header['NAXIS1']\n1031 |                 tile_size[1] = self._image_header['NAXIS2']\n1032 | \n1033 |                 for i in range(2, naxis):\n1034 |                     # set all higher tile dimensions = 1\n1035 |                     tile_size[i] = 1\n1036 |             elif not tile_size:\n1037 |                 # The Hcompress algorithm is inherently 2D in nature, so the\n1038 |                 # row by row tiling that is used for other compression\n1039 |                 # algorithms is not appropriate.  If the image has less than 30\n1040 |                 # rows, then the entire image will be compressed as a single\n1041 |                 # tile.  Otherwise the tiles will consist of 16 rows of the\n1042 |                 # image.  This keeps the tiles to a reasonable size, and it\n1043 |                 # also includes enough rows to allow good compression\n1044 |                 # efficiency.  It the last tile of the image happens to contain\n1045 |                 # less than 4 rows, then find another tile size with between 14\n1046 |                 # and 30 rows (preferably even), so that the last tile has at\n1047 |                 # least 4 rows.\n1048 | \n1049 |                 # 1st tile dimension is the row length of the image\n1050 |                 tile_size.append(self._image_header['NAXIS1'])\n1051 | \n1052 |                 if self._image_header['NAXIS2'] <= 30:\n1053 |                     tile_size.append(self._image_header['NAXIS1'])\n1054 |                 else:\n1055 |                     # look for another good tile dimension\n1056 |                     naxis2 = self._image_header['NAXIS2']\n1057 |                     for dim in [16, 24, 20, 30, 28, 26, 22, 18, 14]:\n1058 |                         if naxis2 % dim == 0 or naxis2 % dim > 3:\n1059 |                             tile_size.append(dim)\n1060 |                             break\n1061 |                     else:\n1062 |                         tile_size.append(17)\n1063 | \n1064 |                 for i in range(2, naxis):\n1065 |                     # set all higher tile dimensions = 1\n1066 |                     tile_size.append(1)\n1067 | \n1068 |             # check if requested tile size causes the last tile to have\n1069 |             # less than 4 pixels\n1070 | \n1071 |             remain = self._image_header['NAXIS1'] % tile_size[0]  # 1st dimen\n1072 | \n1073 |             if remain > 0 and remain < 4:\n1074 |                 tile_size[0] += 1  # try increasing tile size by 1\n1075 | \n1076 |                 remain = self._image_header['NAXIS1'] % tile_size[0]\n1077 | \n1078 |                 if remain > 0 and remain < 4:\n1079 |                     raise ValueError('Last tile along 1st dimension has '\n1080 |                                      'less than 4 pixels')\n1081 | \n1082 |             remain = self._image_header['NAXIS2'] % tile_size[1]  # 2nd dimen\n1083 | \n1084 |             if remain > 0 and remain < 4:\n1085 |                 tile_size[1] += 1  # try increasing tile size by 1\n1086 | \n1087 |                 remain = self._image_header['NAXIS2'] % tile_size[1]\n1088 | \n1089 |                 if remain > 0 and remain < 4:\n1090 |                     raise ValueError('Last tile along 2nd dimension has '\n1091 |                                      'less than 4 pixels')\n1092 | \n1093 |         # Set up locations for writing the next cards in the header.\n1094 |         last_znaxis = 'ZNAXIS'\n1095 | \n1096 |         if self._image_header['NAXIS'] > 0:\n1097 |             after1 = 'ZNAXIS1'\n1098 |         else:\n1099 |             after1 = 'ZNAXIS'\n1100 | \n1101 |         # Calculate the number of rows in the output table and\n1102 |         # write the ZNAXISn and ZTILEn cards to the table header.\n1103 |         nrows = 0\n1104 | \n1105 |         for idx, axis in enumerate(self._axes):\n1106 |             naxis = 'NAXIS' + str(idx + 1)\n1107 |             znaxis = 'ZNAXIS' + str(idx + 1)\n1108 |             ztile = 'ZTILE' + str(idx + 1)\n1109 | \n1110 |             if tile_size and len(tile_size) >= idx + 1:\n1111 |                 ts = tile_size[idx]\n1112 |             else:\n1113 |                 if ztile not in self._header:\n1114 |                     # Default tile size\n1115 |                     if not idx:\n1116 |                         ts = self._image_header['NAXIS1']\n1117 |                     else:\n1118 |                         ts = 1\n1119 |                 else:\n1120 |                     ts = self._header[ztile]\n1121 |                 tile_size.append(ts)\n1122 | \n1123 |             if not nrows:\n1124 |                 nrows = (axis - 1) // ts + 1\n1125 |             else:\n1126 |                 nrows *= ((axis - 1) // ts + 1)\n1127 | \n1128 |             if image_header and naxis in image_header:\n1129 |                 self._header.set(znaxis, axis, image_header.comments[naxis],\n1130 |                                  after=last_znaxis)\n1131 |             else:\n1132 |                 self._header.set(znaxis, axis,\n1133 |                                  'length of original image axis',\n1134 |                                  after=last_znaxis)\n1135 | \n1136 |             self._header.set(ztile, ts, 'size of tiles to be compressed',\n1137 |                              after=after1)\n1138 |             last_znaxis = znaxis\n1139 |             after1 = ztile\n1140 | \n1141 |         # Set the NAXIS2 header card in the table hdu to the number of\n1142 |         # rows in the table.\n1143 |         self._header.set('NAXIS2', nrows, 'number of rows in table')\n1144 | \n1145 |         self.columns = cols\n1146 | \n1147 |         # Set the compression parameters in the table header.\n1148 | \n1149 |         # First, setup the values to be used for the compression parameters\n1150 |         # in case none were passed in.  This will be either the value\n1151 |         # already in the table header for that parameter or the default\n1152 |         # value.\n1153 |         for idx in itertools.count(1):\n1154 |             zname = 'ZNAME' + str(idx)\n1155 |             if zname not in self._header:\n1156 |                 break\n1157 |             zval = 'ZVAL' + str(idx)\n1158 |             if self._header[zname] == 'NOISEBIT':\n1159 |                 if quantize_level is None:\n1160 |                     quantize_level = self._header[zval]\n1161 |             if self._header[zname] == 'SCALE   ':\n1162 |                 if hcomp_scale is None:\n1163 |                     hcomp_scale = self._header[zval]\n1164 |             if self._header[zname] == 'SMOOTH  ':\n1165 |                 if hcomp_smooth is None:\n1166 |                     hcomp_smooth = self._header[zval]\n1167 | \n1168 |         if quantize_level is None:\n1169 |             quantize_level = DEFAULT_QUANTIZE_LEVEL\n1170 | \n1171 |         if hcomp_scale is None:\n1172 |             hcomp_scale = DEFAULT_HCOMP_SCALE\n1173 | \n1174 |         if hcomp_smooth is None:\n1175 |             hcomp_smooth = DEFAULT_HCOMP_SCALE\n1176 | \n1177 |         # Next, strip the table header of all the ZNAMEn and ZVALn keywords\n1178 |         # that may be left over from the previous data\n1179 |         for idx in itertools.count(1):\n1180 |             zname = 'ZNAME' + str(idx)\n1181 |             if zname not in self._header:\n1182 |                 break\n1183 |             zval = 'ZVAL' + str(idx)\n1184 |             del self._header[zname]\n1185 |             del self._header[zval]\n1186 | \n1187 |         # Finally, put the appropriate keywords back based on the\n1188 |         # compression type.\n1189 | \n1190 |         after_keyword = 'ZCMPTYPE'\n1191 |         idx = 1\n1192 | \n1193 |         if compression_type == 'RICE_1':\n1194 |             self._header.set('ZNAME1', 'BLOCKSIZE', 'compression block size',\n1195 |                              after=after_keyword)\n1196 |             self._header.set('ZVAL1', DEFAULT_BLOCK_SIZE, 'pixels per block',\n1197 |                              after='ZNAME1')\n1198 | \n1199 |             self._header.set('ZNAME2', 'BYTEPIX',\n1200 |                              'bytes per pixel (1, 2, 4, or 8)', after='ZVAL1')\n1201 | \n1202 |             if self._header['ZBITPIX'] == 8:\n1203 |                 bytepix = 1\n1204 |             elif self._header['ZBITPIX'] == 16:\n1205 |                 bytepix = 2\n1206 |             else:\n1207 |                 bytepix = DEFAULT_BYTE_PIX\n1208 | \n1209 |             self._header.set('ZVAL2', bytepix,\n1210 |                              'bytes per pixel (1, 2, 4, or 8)',\n1211 |                              after='ZNAME2')\n1212 |             after_keyword = 'ZVAL2'\n1213 |             idx = 3\n1214 |         elif compression_type == 'HCOMPRESS_1':\n1215 |             self._header.set('ZNAME1', 'SCALE', 'HCOMPRESS scale factor',\n1216 |                              after=after_keyword)\n1217 |             self._header.set('ZVAL1', hcomp_scale, 'HCOMPRESS scale factor',\n1218 |                              after='ZNAME1')\n1219 |             self._header.set('ZNAME2', 'SMOOTH', 'HCOMPRESS smooth option',\n1220 |                              after='ZVAL1')\n1221 |             self._header.set('ZVAL2', hcomp_smooth, 'HCOMPRESS smooth option',\n1222 |                              after='ZNAME2')\n1223 |             after_keyword = 'ZVAL2'\n1224 |             idx = 3\n1225 | \n1226 |         if self._image_header['BITPIX'] < 0:   # floating point image\n1227 |             self._header.set('ZNAME' + str(idx), 'NOISEBIT',\n1228 |                              'floating point quantization level',\n1229 |                              after=after_keyword)\n1230 |             self._header.set('ZVAL' + str(idx), quantize_level,\n1231 |                              'floating point quantization level',\n1232 |                              after='ZNAME' + str(idx))\n1233 | \n1234 |             # Add the dither method and seed\n1235 |             if quantize_method:\n1236 |                 if quantize_method not in [NO_DITHER, SUBTRACTIVE_DITHER_1,\n1237 |                                            SUBTRACTIVE_DITHER_2]:\n1238 |                     name = QUANTIZE_METHOD_NAMES[DEFAULT_QUANTIZE_METHOD]\n1239 |                     warnings.warn('Unknown quantization method provided.  '\n1240 |                                   'Default method ({}) used.'.format(name))\n1241 |                     quantize_method = DEFAULT_QUANTIZE_METHOD\n1242 | \n1243 |                 if quantize_method == NO_DITHER:\n1244 |                     zquantiz_comment = 'No dithering during quantization'\n1245 |                 else:\n1246 |                     zquantiz_comment = 'Pixel Quantization Algorithm'\n1247 | \n1248 |                 self._header.set('ZQUANTIZ',\n1249 |                                  QUANTIZE_METHOD_NAMES[quantize_method],\n1250 |                                  zquantiz_comment,\n1251 |                                  after='ZVAL' + str(idx))\n1252 |             else:\n1253 |                 # If the ZQUANTIZ keyword is missing the default is to assume\n1254 |                 # no dithering, rather than whatever DEFAULT_QUANTIZE_METHOD\n1255 |                 # is set to\n1256 |                 quantize_method = self._header.get('ZQUANTIZ', NO_DITHER)\n1257 | \n1258 |                 if isinstance(quantize_method, str):\n1259 |                     for k, v in QUANTIZE_METHOD_NAMES.items():\n1260 |                         if v.upper() == quantize_method:\n1261 |                             quantize_method = k\n1262 |                             break\n1263 |                     else:\n1264 |                         quantize_method = NO_DITHER\n1265 | \n1266 |             if quantize_method == NO_DITHER:\n1267 |                 if 'ZDITHER0' in self._header:\n1268 |                     # If dithering isn't being used then there's no reason to\n1269 |                     # keep the ZDITHER0 keyword\n1270 |                     del self._header['ZDITHER0']\n1271 |             else:\n1272 |                 if dither_seed:\n1273 |                     dither_seed = self._generate_dither_seed(dither_seed)\n1274 |                 elif 'ZDITHER0' in self._header:\n1275 |                     dither_seed = self._header['ZDITHER0']\n1276 |                 else:\n1277 |                     dither_seed = self._generate_dither_seed(\n1278 |                             DEFAULT_DITHER_SEED)\n1279 | \n1280 |                 self._header.set('ZDITHER0', dither_seed,\n1281 |                                  'dithering offset when quantizing floats',\n1282 |                                  after='ZQUANTIZ')\n1283 | \n1284 |         if image_header:\n1285 |             # Move SIMPLE card from the image header to the\n1286 |             # table header as ZSIMPLE card.\n1287 | \n1288 |             if 'SIMPLE' in image_header:\n1289 |                 self._header.set('ZSIMPLE', image_header['SIMPLE'],\n1290 |                                  image_header.comments['SIMPLE'],\n1291 |                                  before='ZBITPIX')\n1292 | \n1293 |             # Move EXTEND card from the image header to the\n1294 |             # table header as ZEXTEND card.\n1295 | \n1296 |             if 'EXTEND' in image_header:\n1297 |                 self._header.set('ZEXTEND', image_header['EXTEND'],\n1298 |                                  image_header.comments['EXTEND'])\n1299 | \n1300 |             # Move BLOCKED card from the image header to the\n1301 |             # table header as ZBLOCKED card.\n1302 | \n1303 |             if 'BLOCKED' in image_header:\n1304 |                 self._header.set('ZBLOCKED', image_header['BLOCKED'],\n1305 |                                  image_header.comments['BLOCKED'])\n1306 | \n1307 |             # Move XTENSION card from the image header to the\n1308 |             # table header as ZTENSION card.\n1309 | \n1310 |             # Since we only handle compressed IMAGEs, ZTENSION should\n1311 |             # always be IMAGE, even if the caller has passed in a header\n1312 |             # for some other type of extension.\n1313 |             if 'XTENSION' in image_header:\n1314 |                 self._header.set('ZTENSION', 'IMAGE',\n1315 |                                  image_header.comments['XTENSION'],\n1316 |                                  before='ZBITPIX')\n1317 | \n1318 |             # Move PCOUNT and GCOUNT cards from image header to the table\n1319 |             # header as ZPCOUNT and ZGCOUNT cards.\n1320 | \n1321 |             if 'PCOUNT' in image_header:\n1322 |                 self._header.set('ZPCOUNT', image_header['PCOUNT'],\n1323 |                                  image_header.comments['PCOUNT'],\n1324 |                                  after=last_znaxis)\n1325 | \n1326 |             if 'GCOUNT' in image_header:\n1327 |                 self._header.set('ZGCOUNT', image_header['GCOUNT'],\n1328 |                                  image_header.comments['GCOUNT'],\n1329 |                                  after='ZPCOUNT')\n1330 | \n1331 |             # Move CHECKSUM and DATASUM cards from the image header to the\n1332 |             # table header as XHECKSUM and XDATASUM cards.\n1333 | \n1334 |             if 'CHECKSUM' in image_header:\n1335 |                 self._header.set('ZHECKSUM', image_header['CHECKSUM'],\n1336 |                                  image_header.comments['CHECKSUM'])\n1337 | \n1338 |             if 'DATASUM' in image_header:\n1339 |                 self._header.set('ZDATASUM', image_header['DATASUM'],\n1340 |                                  image_header.comments['DATASUM'])\n1341 |         else:\n1342 |             # Move XTENSION card from the image header to the\n1343 |             # table header as ZTENSION card.\n1344 | \n1345 |             # Since we only handle compressed IMAGEs, ZTENSION should\n1346 |             # always be IMAGE, even if the caller has passed in a header\n1347 |             # for some other type of extension.\n1348 |             if 'XTENSION' in self._image_header:\n1349 |                 self._header.set('ZTENSION', 'IMAGE',\n1350 |                                  self._image_header.comments['XTENSION'],\n1351 |                                  before='ZBITPIX')\n1352 | \n1353 |             # Move PCOUNT and GCOUNT cards from image header to the table\n1354 |             # header as ZPCOUNT and ZGCOUNT cards.\n1355 | \n1356 |             if 'PCOUNT' in self._image_header:\n1357 |                 self._header.set('ZPCOUNT', self._image_header['PCOUNT'],\n1358 |                                  self._image_header.comments['PCOUNT'],\n1359 |                                  after=last_znaxis)\n1360 | \n1361 |             if 'GCOUNT' in self._image_header:\n1362 |                 self._header.set('ZGCOUNT', self._image_header['GCOUNT'],\n1363 |                                  self._image_header.comments['GCOUNT'],\n1364 |                                  after='ZPCOUNT')\n1365 | \n1366 |         # When we have an image checksum we need to ensure that the same\n1367 |         # number of blank cards exist in the table header as there were in\n1368 |         # the image header.  This allows those blank cards to be carried\n1369 |         # over to the image header when the hdu is uncompressed.\n1370 | \n1371 |         if 'ZHECKSUM' in self._header:\n1372 |             required_blanks = image_header._countblanks()\n1373 |             image_blanks = self._image_header._countblanks()\n1374 |             table_blanks = self._header._countblanks()\n1375 | \n1376 |             for _ in range(required_blanks - image_blanks):\n1377 |                 self._image_header.append()\n1378 |                 table_blanks += 1\n1379 | \n1380 |             for _ in range(required_blanks - table_blanks):\n1381 |                 self._header.append()\n```\n\nFound class `astropy/modeling/projections.py:Pix2Sky_ZenithalPerspective`.\nSource: Retrieved entity using keyword search (bm25).\n```\n269 | class Pix2Sky_ZenithalPerspective(Pix2SkyProjection, Zenithal):\n270 |     r\"\"\"\n271 |     Zenithal perspective projection - pixel to sky.\n272 | \n273 |     Corresponds to the ``AZP`` projection in FITS WCS.\n274 | \n275 |     .. math::\n276 |         \\phi &= \\arg(-y \\cos \\gamma, x) \\\\\n277 |         \\theta &= \\left\\{\\genfrac{}{}{0pt}{}{\\psi - \\omega}{\\psi + \\omega + 180^{\\circ}}\\right.\n278 | \n279 |     where:\n280 | \n281 |     .. math::\n282 |         \\psi &= \\arg(\\rho, 1) \\\\\n283 |         \\omega &= \\sin^{-1}\\left(\\frac{\\rho \\mu}{\\sqrt{\\rho^2 + 1}}\\right) \\\\\n284 |         \\rho &= \\frac{R}{\\frac{180^{\\circ}}{\\pi}(\\mu + 1) + y \\sin \\gamma} \\\\\n285 |         R &= \\sqrt{x^2 + y^2 \\cos^2 \\gamma}\n286 | \n287 |     Parameters\n288 |     ----------\n289 |     mu : float\n290 |         Distance from point of projection to center of sphere\n291 |         in spherical radii, \u03bc.  Default is 0.\n292 | \n293 |     gamma : float\n294 |         Look angle \u03b3 in degrees.  Default is 0\u00b0.\n295 | \n296 |     \"\"\"\n297 |     mu = _ParameterDS(\n298 |         default=0.0, description=\"Distance from point of projection to center of sphere\"\n299 |     )\n300 |     gamma = _ParameterDS(default=0.0, getter=_to_orig_unit, setter=_to_radian,\n301 |                          description=\"Look angle \u03b3 in degrees (Default = 0\u00b0)\")\n302 | \n303 |     @mu.validator\n304 |     def mu(self, value):\n305 |         if np.any(np.equal(value, -1.0)):\n306 |             raise InputParameterError(\n307 |                 \"Zenithal perspective projection is not defined for mu = -1\")\n```\n\nFound class `astropy/modeling/projections.py:Pix2Sky_SlantZenithalPerspective`.\nSource: Retrieved entity using keyword search (bm25).\n```\n349 | class Pix2Sky_SlantZenithalPerspective(Pix2SkyProjection, Zenithal):\n350 |     r\"\"\"\n351 |     Slant zenithal perspective projection - pixel to sky.\n352 | \n353 |     Corresponds to the ``SZP`` projection in FITS WCS.\n354 | \n355 |     Parameters\n356 |     ----------\n357 |     mu : float\n358 |         Distance from point of projection to center of sphere\n359 |         in spherical radii, \u03bc.  Default is 0.\n360 | \n361 |     phi0 : float\n362 |         The longitude \u03c6\u2080 of the reference point, in degrees.  Default\n363 |         is 0\u00b0.\n364 | \n365 |     theta0 : float\n366 |         The latitude \u03b8\u2080 of the reference point, in degrees.  Default\n367 |         is 90\u00b0.\n368 | \n369 |     \"\"\"\n370 |     mu = _ParameterDS(\n371 |         default=0.0,\n372 |         description=\"Distance from point of projection to center of sphere\"\n373 |     )\n374 |     phi0 = _ParameterDS(\n375 |         default=0.0, getter=_to_orig_unit, setter=_to_radian,\n376 |         description=\"The longitude \u03c6\u2080 of the reference point in degrees (Default=0\u00b0)\"\n377 |     )\n378 |     theta0 = _ParameterDS(\n379 |         default=90.0, getter=_to_orig_unit, setter=_to_radian,\n380 |         description=\"The latitude \u03b8\u2080 of the reference point, in degrees (Default=0\u00b0)\"\n381 |     )\n382 | \n383 |     @mu.validator\n384 |     def mu(self, value):\n385 |         if np.any(np.equal(value, -1.0)):\n386 |             raise InputParameterError(\n387 |                 \"Zenithal perspective projection is not defined for mu = -1\")\n```\n\nFound function `astropy/io/fits/hdu/compressed.py:CompImageHDU.data`.\nSource: Retrieved code content using keyword search (bm25).\n```\n1427 | def data(self, data):\n1428 |         if (data is not None) and (not isinstance(data, np.ndarray) or\n1429 |                 data.dtype.fields is not None):\n1430 |             raise TypeError('CompImageHDU data has incorrect type:{}; '\n1431 |                             'dtype.fields = {}'.format(\n1432 |                     type(data), data.dtype.fields))\n```\n\nFound function `astropy/io/fits/hdu/compressed.py:CompImageHDU.compressed_data`.\nSource: Retrieved code content using keyword search (bm25).\n```\n1454 | def compressed_data(self):\n1455 |         # Deleting the compressed_data attribute has to be handled\n1456 |         # with a little care to prevent a reference leak\n1457 |         # First delete the ._coldefs attributes under it to break a possible\n1458 |         # reference cycle\n1459 |         if 'compressed_data' in self.__dict__:\n1460 |             del self.__dict__['compressed_data']._coldefs\n1461 | \n1462 |             # Now go ahead and delete from self.__dict__; normally\n1463 |             # lazyproperty.__delete__ does this for us, but we can prempt it to\n1464 |             # do some additional cleanup\n1465 |             del self.__dict__['compressed_data']\n1466 | \n1467 |             # If this file was mmap'd, numpy.memmap will hold open a file\n1468 |             # handle until the underlying mmap object is garbage-collected;\n1469 |             # since this reference leak can sometimes hang around longer than\n1470 |             # welcome go ahead and force a garbage collection\n1471 |             gc.collect()\n```\n\nFound function `astropy/io/fits/hdu/compressed.py:CompImageHDU.shape`.\nSource: Retrieved code content using keyword search (bm25).\n```\n1474 | def shape(self):\n1475 |         \"\"\"\n1476 |         Shape of the image array--should be equivalent to ``self.data.shape``.\n1477 |         \"\"\"\n1478 | \n1479 |         # Determine from the values read from the header\n1480 |         return tuple(reversed(self._axes))\n```\n"}, {"role": "tool", "tool_call_id": "call_8EDxfen3uCRMXc7w6OgcOnoy", "name": "explore_tree_structure", "content": "OBSERVATION:\n/\n\u251c\u2500\u2500 contains \u2500\u2500 setup.py\n\u251c\u2500\u2500 contains \u2500\u2500 conftest.py\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 conftest.py:pytest_configure\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 conftest.py:pytest_report_header\n\u2502               \u2514\u2500\u2500 imports \u2500\u2500 astropy/__init__.py\n\u251c\u2500\u2500 contains \u2500\u2500 astropy\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/version.py\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/__init__.py\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/logger.py\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/conftest.py\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/cosmology\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/uncertainty\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/wcs\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/table\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/_erfa\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/constants\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/convolution\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/config\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/extern\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/nddata\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/samp\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/coordinates\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/visualization\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/timeseries\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/units\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/io\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/_dev\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/stats\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/utils\n\u2502               \u2514\u2500\u2500 contains \u2500\u2500 astropy/time\n\u251c\u2500\u2500 contains \u2500\u2500 .pyinstaller\n\u2502               \u2514\u2500\u2500 contains \u2500\u2500 .pyinstaller/hooks\n\u251c\u2500\u2500 contains \u2500\u2500 docs\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 docs/conf.py\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 docs/conftest.py\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 docs/wcs\n\u2502               \u2514\u2500\u2500 contains \u2500\u2500 docs/nddata\n\u2514\u2500\u2500 contains \u2500\u2500 examples\n                \u251c\u2500\u2500 contains \u2500\u2500 examples/coordinates\n                \u251c\u2500\u2500 contains \u2500\u2500 examples/template\n                \u2514\u2500\u2500 contains \u2500\u2500 examples/io\n"}, {"content": "```\nastropy/modeling/separable.py:separability_matrix\nastropy/modeling/functional_models.py:Linear1D\nastropy/modeling/core.py:CompoundModel\nastropy/modeling/core.py:CompoundModel.n_inputs\nastropy/modeling/core.py:CompoundModel.n_outputs\nastropy/modeling/core.py:CompoundModel.eqcons\nastropy/modeling/core.py:CompoundModel.ineqcons\nastropy/modeling/projections.py:Pix2Sky_ZenithalPerspective\nastropy/modeling/projections.py:Pix2Sky_SlantZenithalPerspective\nastropy/io/fits/hdu/compressed.py:CompImageHDU.data\n```", "role": "assistant", "tool_calls": null, "function_call": null}, {"role": "user", "content": "Verify if the found locations contain all the necessary information to address the issue, and check for any relevant references in other parts of the codebase that may not have appeared in the search results. If not, continue searching for additional locations related to the issue.\nVerify that you have carefully analyzed the impact of the found locations on the repository, especially their dependencies. If you think you have solved the task, please send your final answer (including the former answer and reranking) to user through message and then call `finish` to finish.\nIMPORTANT: YOU SHOULD NEVER ASK FOR HUMAN HELP.\n"}, {"content": null, "role": "assistant", "tool_calls": [{"function": {"arguments": "{\"start_entities\": [\"astropy/modeling/separable.py:separability_matrix\", \"astropy/modeling/functional_models.py:Linear1D\", \"astropy/modeling/core.py:CompoundModel\", \"astropy/modeling/projections.py:Pix2Sky_ZenithalPerspective\", \"astropy/modeling/projections.py:Pix2Sky_SlantZenithalPerspective\"], \"traversal_depth\": 2, \"direction\": \"both\"}", "name": "explore_tree_structure"}, "id": "call_So4oh6LWnP3poT1LZlv3MNM3", "type": "function"}, {"function": {"arguments": "{\"entity_names\": [\"astropy/modeling/separable.py:separability_matrix\", \"astropy/modeling/functional_models.py:Linear1D\", \"astropy/modeling/core.py:CompoundModel\", \"astropy/modeling/projections.py:Pix2Sky_ZenithalPerspective\", \"astropy/modeling/projections.py:Pix2Sky_SlantZenithalPerspective\"]}", "name": "get_entity_contents"}, "id": "call_I2HdoJtDqbSz3a2nQwF8p9Mr", "type": "function"}], "function_call": null}, {"role": "tool", "tool_call_id": "call_So4oh6LWnP3poT1LZlv3MNM3", "name": "explore_tree_structure", "content": "OBSERVATION:\nastropy/modeling/separable.py:separability_matrix\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/index.py:SlicedIndex.where\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/index.py:SlicedIndex.where\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity_helper/function_helpers.py:where\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/masked/function_helpers.py:where\n\u2502              \u2514\u2500\u2500 invokes \u2500\u2500 astropy/table/index.py:SlicedIndex.sliced_coords\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity_helper/function_helpers.py:where\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/masked/function_helpers.py:where\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/separable.py:_separable\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/separable.py:_coord_matrix\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:TableColumns.isinstance\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/separable.py:_separable\n\u2502              \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model._calculate_separability_matrix\n\u2514\u2500\u2500 contains-by \u2500\u2500 astropy/modeling/separable.py\n                   \u251c\u2500\u2500 contains-by \u2500\u2500 astropy/modeling\n                   \u2514\u2500\u2500 imports-by \u2500\u2500 astropy/modeling/__init__.py\n\nastropy/modeling/functional_models.py:Linear1D\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/functional_models.py:Linear1D.evaluate\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/functional_models.py:Linear1D.fit_deriv\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/utils/masked/function_helpers.py:ones_like\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/functional_models.py:Linear1D.inverse\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/functional_models.py:Linear1D.input_units\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/functional_models.py:Linear1D._parameter_units_for_data_units\n\u251c\u2500\u2500 inherits \u2500\u2500 astropy/modeling/core.py:Fittable1DModel\n\u2502               \u2514\u2500\u2500 inherits \u2500\u2500 astropy/modeling/core.py:FittableModel\n\u251c\u2500\u2500 contains-by \u2500\u2500 astropy/modeling/functional_models.py\n\u2502                  \u251c\u2500\u2500 contains-by \u2500\u2500 astropy/modeling\n\u2502                  \u251c\u2500\u2500 imports-by \u2500\u2500 astropy/modeling/models.py\n\u2502                  \u251c\u2500\u2500 imports-by \u2500\u2500 astropy/io/misc/asdf/tags/transform/physical_models.py\n\u2502                  \u251c\u2500\u2500 imports-by \u2500\u2500 astropy/io/misc/asdf/tags/transform/basic.py\n\u2502                  \u2514\u2500\u2500 imports-by \u2500\u2500 astropy/io/misc/asdf/tags/transform/functional_models.py\n\u2514\u2500\u2500 invokes-by \u2500\u2500 astropy/io/misc/asdf/tags/transform/polynomial.py:Linear1DType.from_tree_transform\n                  \u2514\u2500\u2500 contains-by \u2500\u2500 astropy/io/misc/asdf/tags/transform/polynomial.py:Linear1DType\n\nastropy/modeling/core.py:CompoundModel\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._get_left_inputs_from_args\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._get_right_inputs_from_args\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._get_left_params_from_args\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._get_right_params_from_args\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._get_kwarg_model_parameters_as_positional\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity_helper/function_helpers.py:append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/convenience.py:append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/header.py:Header.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/hdu/compressed.py:CompImageHeader.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/hdu/hdulist.py:HDUList.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/collections.py:HomogeneousList.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/masked/function_helpers.py:append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/extern/configobj/configobj.py:Section.pop\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/header.py:Header.pop\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/hdu/hdulist.py:HDUList.pop\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._apply_operators_to_value_lists\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:ModelDefinitionError\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:TableColumns.isinstance\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:binary_operation\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.evaluate\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._get_left_inputs_from_args\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/soco.py:SCEngine.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/sorted_array.py:SortedArray.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/config/configuration.py:ConfigNamespace.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/bst.py:BST.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/structured.py:StructuredUnit.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/mappings.py:UnitsMapping.evaluate\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model.evaluate\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:TableColumns.isinstance\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._get_right_inputs_from_args\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._apply_operators_to_value_lists\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/extern/configobj/configobj.py:Section.dict\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._get_left_params_from_args\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._get_kwarg_model_parameters_as_positional\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/votable/tree.py:Values.type\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/votable/tree.py:Field.type\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/votable/tree.py:Resource.type\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._get_right_params_from_args\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/sorted_array.py:SortedArray.range\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/bst.py:BST.range\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/soco.py:SCEngine.range\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/groups.py:ColumnGroups.keys\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/structured.py:StructuredUnit.keys\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/groups.py:TableGroups.keys\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.keys\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.n_submodels\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._make_leaflist\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.submodel_names\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._make_leaflist\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity_helper/function_helpers.py:append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/convenience.py:append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/header.py:Header.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/hdu/compressed.py:CompImageHeader.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/hdu/hdulist.py:HDUList.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/collections.py:HomogeneousList.append\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/utils/masked/function_helpers.py:append\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.both_inverses_exist\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._pre_evaluate\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._pre_evaluate.evaluate\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/soco.py:SCEngine.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/sorted_array.py:SortedArray.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/config/configuration.py:ConfigNamespace.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/bst.py:BST.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/structured.py:StructuredUnit.items\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel.inputs_map\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._argnames\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._post_evaluate\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model.get_bounding_box\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._evaluate\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity_helper/function_helpers.py:append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/convenience.py:append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/header.py:Header.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/hdu/compressed.py:CompImageHeader.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/hdu/hdulist.py:HDUList.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/collections.py:HomogeneousList.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/masked/function_helpers.py:append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:TableColumns.isinstance\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity.py:Quantity.insert\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/column.py:Column.insert\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/column.py:MaskedColumn.insert\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity.py:QuantityIterator.index\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/soco.py:SCEngine.sort\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/bst.py:BST.sort\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/sorted_array.py:SortedArray.sort\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.sort\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/votable/tree.py:Values.type\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/votable/tree.py:Field.type\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/votable/tree.py:Resource.type\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._apply_operators_to_value_lists\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/groups.py:ColumnGroups.keys\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/structured.py:StructuredUnit.keys\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/groups.py:TableGroups.keys\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.keys\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.param_names\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._make_leaflist\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.__getattr__\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.__getitem__\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._make_leaflist\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:TableColumns.isinstance\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._str_index_to_int\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/votable/tree.py:Values.type\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/votable/tree.py:Field.type\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/io/votable/tree.py:Resource.type\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._str_index_to_int\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.n_inputs\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.n_outputs\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.eqcons\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.ineqcons\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.traverse_postorder\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity_helper/function_helpers.py:append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/convenience.py:append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/header.py:Header.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/hdu/compressed.py:CompImageHeader.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/hdu/hdulist.py:HDUList.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/collections.py:HomogeneousList.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/masked/function_helpers.py:append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel.traverse_postorder\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:TableColumns.isinstance\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._format_expression\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/operations.py:join\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel.traverse_postorder\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/extern/configobj/configobj.py:Section.pop\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/header.py:Header.pop\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/hdu/hdulist.py:HDUList.pop\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity_helper/function_helpers.py:append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/convenience.py:append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/header.py:Header.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/hdu/compressed.py:CompImageHeader.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/hdu/hdulist.py:HDUList.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/collections.py:HomogeneousList.append\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/masked/function_helpers.py:append\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:TableColumns.isinstance\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._format_components\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/operations.py:join\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._map_parameters\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/column.py:BaseColumn.format\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/visualization/time.py:time_support.MplTimeConverter.format\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/visualization/wcsaxes/formatter_locator.py:AngleFormatterLocator.format\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/visualization/wcsaxes/formatter_locator.py:ScalarFormatterLocator.format\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/votable/tree.py:Table.format\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/time/core.py:TimeBase.format\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.__str__\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._format_expression\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model._format_str\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/misc.py:indent\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._format_components\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.rename\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.isleaf\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.inverse\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.fittable\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._map_parameters\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity.py:Quantity.all\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._map_parameters\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._map_parameters\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._initialize_slices\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/wcs/wcs.py:WCS.slice\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/parameters.py:Parameter.shape\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/shapes.py:ShapedLikeNDArray.shape\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/shapes.py:ShapedLikeNDArray.size\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/parameters.py:Parameter.size\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._recursive_lookup\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:TableColumns.isinstance\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.inputs_map\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/powerlaws.py:PowerLaw1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/powerlaws.py:BrokenPowerLaw1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/powerlaws.py:SmoothlyBrokenPowerLaw1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/powerlaws.py:ExponentialCutoffPowerLaw1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/powerlaws.py:LogParabola1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/physical_models.py:BlackBody._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/physical_models.py:Drude1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/physical_models.py:Plummer1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/physical_models.py:NFW._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/polynomial.py:Polynomial1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/polynomial.py:Polynomial2D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Gaussian1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Gaussian2D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Shift._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Scale._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Multiply._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Sersic1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:_Trigonometric1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:_InverseTrigonometric1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Linear1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Planar2D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Lorentz1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Voigt1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Const1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Const2D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Ellipse2D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Disk2D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Ring2D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Box1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Box2D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Trapezoid1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:TrapezoidDisk2D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:RickerWavelet1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:RickerWavelet2D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:AiryDisk2D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Moffat1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Moffat2D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Sersic2D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:KingProjectedAnalytic1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Logarithmic1D._parameter_units_for_data_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/functional_models.py:Exponential1D._parameter_units_for_data_units\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._map_parameters\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.input_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/soco.py:SCEngine.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/sorted_array.py:SortedArray.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/config/configuration.py:ConfigNamespace.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/bst.py:BST.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/structured.py:StructuredUnit.items\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel.inputs_map\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.input_units_equivalencies\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/soco.py:SCEngine.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/sorted_array.py:SortedArray.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/config/configuration.py:ConfigNamespace.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/bst.py:BST.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/structured.py:StructuredUnit.items\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel.inputs_map\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.input_units_allow_dimensionless\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/soco.py:SCEngine.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/sorted_array.py:SortedArray.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/config/configuration.py:ConfigNamespace.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/bst.py:BST.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/structured.py:StructuredUnit.items\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel.inputs_map\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.input_units_strict\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/soco.py:SCEngine.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/sorted_array.py:SortedArray.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/config/configuration.py:ConfigNamespace.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/bst.py:BST.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/structured.py:StructuredUnit.items\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel.inputs_map\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.return_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/soco.py:SCEngine.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/sorted_array.py:SortedArray.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/config/configuration.py:ConfigNamespace.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/bst.py:BST.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/structured.py:StructuredUnit.items\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel.outputs_map\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.outputs_map\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.has_user_bounding_box\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.render\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/nddata/utils.py:add_array\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity.py:Quantity.mean\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/nddata/utils.py:extract_array\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/wcs/wcs.py:WCS.slice\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model.get_bounding_box\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/convolution/core.py:Kernel.array\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/convolution/kernels.py:CustomKernel.array\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/nddata/nduncertainty.py:NDUncertainty.array\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/column.py:Column.array\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.replace_submodel\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel.traverse_postorder\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/extern/configobj/configobj.py:Section.pop\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/header.py:Header.pop\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/hdu/hdulist.py:HDUList.pop\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:_get_submodel_path\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity.py:QuantityIterator.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/parameters.py:Parameter.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:ModelBoundingBox.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/shapes.py:NDArrayShapeMethods.copy\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:CompoundBoundingBox.copy\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel._set_sub_models_and_parameter_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity.py:SpecificTypeQuantity._set_unit\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/function/core.py:FunctionQuantity._set_unit\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity.py:Quantity._set_unit\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/parameters.py:Parameter._set_unit\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.without_units_for_data\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._set_sub_models_and_parameter_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:TableColumns.isinstance\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model.output_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity.py:QuantityIterator.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/parameters.py:Parameter.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:ModelBoundingBox.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/shapes.py:NDArrayShapeMethods.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:CompoundBoundingBox.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model.without_units_for_data\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.update\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:CompoundModel.with_units_from_data\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/extern/configobj/configobj.py:Section.pop\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/header.py:Header.pop\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/hdu/hdulist.py:HDUList.pop\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._set_sub_models_and_parameter_units\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity.py:QuantityIterator.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/parameters.py:Parameter.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:ModelBoundingBox.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/shapes.py:NDArrayShapeMethods.copy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:CompoundBoundingBox.copy\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model.with_units_from_data\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/utils.py:combine_labels\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/__init__.py:base_constants_version.set\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:PprintIncludeExclude.set\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/bst.py:Node.set\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/config/configuration.py:ConfigItem.set\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/header.py:Header.set\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/decorators.py:deprecated_attribute.set\n\u2502              \u2514\u2500\u2500 invokes \u2500\u2500 astropy/utils/state.py:ScienceState.set\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.reverse\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/structured.py:StructuredUnit.values\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/row.py:Row.values\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/config/configuration.py:ConfigNamespace.values\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.values\n\u2502              \u2514\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.reverse\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:ModelDefinitionError\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:TableColumns.isinstance\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity_helper/function_helpers.py:append\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/convenience.py:append\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/header.py:Header.append\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/hdu/compressed.py:CompImageHeader.append\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/hdu/hdulist.py:HDUList.append\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/collections.py:HomogeneousList.append\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/masked/function_helpers.py:append\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity.py:QuantityIterator.index\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/soco.py:SCEngine.sort\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/bst.py:BST.sort\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/sorted_array.py:SortedArray.sort\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.sort\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/column.py:BaseColumn.format\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/visualization/time.py:time_support.MplTimeConverter.format\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/visualization/wcsaxes/formatter_locator.py:AngleFormatterLocator.format\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/visualization/wcsaxes/formatter_locator.py:ScalarFormatterLocator.format\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/votable/tree.py:Table.format\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/time/core.py:TimeBase.format\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/votable/tree.py:Values.type\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/votable/tree.py:Field.type\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/votable/tree.py:Resource.type\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:ModelBoundingBox.fix_inputs\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:_SelectorArguments.validate\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:ModelBoundingBox.validate\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:_SelectorArgument.validate\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:CompoundBoundingBox.validate\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:_Interval.validate\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:_Interval.copy\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity.py:QuantityIterator.copy\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:ModelBoundingBox.copy\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/shapes.py:NDArrayShapeMethods.copy\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:CompoundBoundingBox.copy\n\u2502              \u2514\u2500\u2500 invokes \u2500\u2500 astropy/units/structured.py:StructuredUnit.keys\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:fix_inputs\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:ModelBoundingBox.validate\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:CompoundBoundingBox.validate\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/parameters.py:Parameter.validate\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:_SelectorArguments.get_fixed_values\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/groups.py:ColumnGroups.keys\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/structured.py:StructuredUnit.keys\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/groups.py:TableGroups.keys\n\u2502              \u2514\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.keys\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:CompoundBoundingBox.fix_inputs\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/extern/configobj/configobj.py:Section.pop\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/header.py:Header.pop\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/hdu/hdulist.py:HDUList.pop\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:CompoundBoundingBox._fix_input_selector_arg\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:_SelectorArgument.is_argument\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:_SelectorArguments.is_argument\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:CompoundBoundingBox._fix_input_bbox_arg\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:TableColumns.isinstance\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:_Interval.copy\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity.py:QuantityIterator.copy\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:ModelBoundingBox.copy\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/shapes.py:NDArrayShapeMethods.copy\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:CompoundBoundingBox.copy\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:_SelectorArguments.validate\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:ModelBoundingBox.validate\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:_SelectorArgument.validate\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:CompoundBoundingBox.validate\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:_Interval.validate\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:ModelBoundingBox.fix_inputs\n\u2502              \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/bounding_box.py:_BoundingDomain.fix_inputs\n\u2502              \u2514\u2500\u2500 invokes \u2500\u2500 astropy/units/structured.py:StructuredUnit.keys\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/groups.py:ColumnGroups.keys\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/structured.py:StructuredUnit.keys\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/groups.py:TableGroups.keys\n\u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.keys\n\u251c\u2500\u2500 inherits \u2500\u2500 astropy/modeling/core.py:Model\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.__init_subclass__\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._default_inputs_outputs\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model._default_inputs_outputs\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._initialize_setters\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model._initialize_setters\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.inputs\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.outputs\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.n_inputs\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.n_outputs\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._calculate_separability_matrix\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._initialize_unit_support\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model._initialize_unit_support\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.input_units_strict\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.input_units_allow_dimensionless\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.uses_quantity\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.__repr__\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.__str__\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.__len__\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._strip_ones\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.__setattr__\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._pre_evaluate\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.get_bounding_box\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._argnames\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._validate_input_shape\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._validate_input_shapes\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.input_shape\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._generic_evaluate\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._post_evaluate\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.bbox_with_units\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.__call__\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._get_renamed_inputs_as_positional\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.name\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.model_set_axis\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.param_sets\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.parameters\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.sync_constraints\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.fixed\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.bounds\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.tied\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.eqcons\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.ineqcons\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.has_inverse\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.inverse\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.has_user_inverse\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.bounding_box\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.set_slice_args\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.has_user_bounding_box\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.cov_matrix\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.stds\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.separable\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.without_units_for_data\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.output_units\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.strip_units_from_tree\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.with_units_from_data\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._has_units\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._supports_unit_fitting\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.evaluate\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.sum_of_implicit_terms\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.render\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.input_units\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.return_units\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._prepare_inputs_single_model\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._remove_axes_from_shape\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._prepare_inputs_model_set\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.prepare_inputs\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._validate_input_units\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._process_output_units\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._prepare_output_single_model\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._prepare_outputs_single_model\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._prepare_outputs_model_set\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.prepare_outputs\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.copy\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.deepcopy\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model.deepcopy\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.rename\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.coerce_units\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model.n_submodels\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._initialize_constraints\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model._initialize_constraints\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._initialize_parameters\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model._initialize_parameters\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._initialize_parameter_value\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._initialize_slices\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:Model._initialize_slices\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._parameters_to_array\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._array_to_parameters\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._check_param_broadcast\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._param_sets\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._format_repr\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/core.py:Model._format_str\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/soco.py:SCEngine.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/sorted_array.py:SortedArray.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/config/configuration.py:ConfigNamespace.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:Table.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/bst.py:BST.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/structured.py:StructuredUnit.items\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:_ModelMeta._handle_special_methods.__init__\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:CompoundModel._initialize_slices\n\u251c\u2500\u2500 contains-by \u2500\u2500 astropy/modeling/core.py\n\u2502                  \u251c\u2500\u2500 contains-by \u2500\u2500 astropy/modeling\n\u2502                  \u251c\u2500\u2500 imports-by \u2500\u2500 astropy/modeling/__init__.py\n\u2502                  \u251c\u2500\u2500 imports-by \u2500\u2500 astropy/modeling/convolution.py\n\u2502                  \u2514\u2500\u2500 imports-by \u2500\u2500 astropy/convolution/convolve.py\n\u251c\u2500\u2500 imports-by \u2500\u2500 astropy/modeling/convolution.py\n\u251c\u2500\u2500 imports-by \u2500\u2500 astropy/modeling/separable.py\n\u2502                 \u251c\u2500\u2500 contains-by \u2500\u2500 astropy/modeling\n\u2502                 \u2514\u2500\u2500 imports-by \u2500\u2500 astropy/modeling/__init__.py\n\u251c\u2500\u2500 imports-by \u2500\u2500 astropy/convolution/convolve.py\n\u251c\u2500\u2500 imports-by \u2500\u2500 astropy/io/misc/asdf/tags/transform/compound.py\n\u2502                 \u251c\u2500\u2500 contains-by \u2500\u2500 astropy/io/misc/asdf/tags/transform\n\u2502                 \u2514\u2500\u2500 imports-by \u2500\u2500 astropy/io/misc/asdf/extension.py\n\u251c\u2500\u2500 imports-by \u2500\u2500 astropy/io/misc/asdf/tags/transform/basic.py\n\u2502                 \u251c\u2500\u2500 contains-by \u2500\u2500 astropy/io/misc/asdf/tags/transform\n\u2502                 \u2514\u2500\u2500 imports-by \u2500\u2500 astropy/io/misc/asdf/extension.py\n\u251c\u2500\u2500 invokes-by \u2500\u2500 astropy/modeling/core.py:_model_oper\n\u2502                 \u251c\u2500\u2500 contains-by \u2500\u2500 astropy/modeling/core.py\n\u2502                 \u2514\u2500\u2500 invokes-by \u2500\u2500 astropy/modeling/core.py:_ModelMeta.__new__\n\u251c\u2500\u2500 invokes-by \u2500\u2500 astropy/modeling/core.py:CompoundModel.replace_submodel\n\u251c\u2500\u2500 invokes-by \u2500\u2500 astropy/modeling/core.py:CompoundModel._set_sub_models_and_parameter_units\n\u251c\u2500\u2500 invokes-by \u2500\u2500 astropy/modeling/core.py:fix_inputs\n\u251c\u2500\u2500 inherits-by \u2500\u2500 astropy/modeling/convolution.py:Convolution\n\u2502                  \u251c\u2500\u2500 contains-by \u2500\u2500 astropy/modeling/convolution.py\n\u2502                  \u251c\u2500\u2500 imports-by \u2500\u2500 astropy/convolution/convolve.py\n\u2502                  \u2514\u2500\u2500 invokes-by \u2500\u2500 astropy/convolution/convolve.py:convolve_models_fft\n\u251c\u2500\u2500 invokes-by \u2500\u2500 astropy/convolution/convolve.py:convolve_models\n\u2502                 \u251c\u2500\u2500 contains-by \u2500\u2500 astropy/convolution/convolve.py\n\u2502                 \u2514\u2500\u2500 imports-by \u2500\u2500 astropy/convolution/__init__.py\n\u2514\u2500\u2500 invokes-by \u2500\u2500 astropy/io/misc/asdf/tags/transform/compound.py:CompoundType.from_tree_tagged\n                  \u2514\u2500\u2500 contains-by \u2500\u2500 astropy/io/misc/asdf/tags/transform/compound.py:CompoundType\n\nastropy/modeling/projections.py:Pix2Sky_ZenithalPerspective\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/projections.py:Pix2Sky_ZenithalPerspective.mu\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity.py:Quantity.any\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/parameters.py:InputParameterError\n\u251c\u2500\u2500 inherits \u2500\u2500 astropy/modeling/projections.py:Pix2SkyProjection\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/projections.py:Pix2SkyProjection.__new__\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/projections.py:Pix2SkyProjection.input_units\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/projections.py:Pix2SkyProjection.return_units\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/projections.py:Pix2SkyProjection.evaluate\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/projections.py:Pix2SkyProjection.inverse\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/__init__.py:base_constants_version.set\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:PprintIncludeExclude.set\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/bst.py:Node.set\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/config/configuration.py:ConfigItem.set\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/header.py:Header.set\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/decorators.py:deprecated_attribute.set\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/state.py:ScienceState.set\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:_ModelMeta._handle_special_methods.__init__\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/projections.py:Projection._update_prj\n\u2502               \u2514\u2500\u2500 inherits \u2500\u2500 astropy/modeling/projections.py:Projection\n\u251c\u2500\u2500 inherits \u2500\u2500 astropy/modeling/projections.py:Zenithal\n\u2502               \u2514\u2500\u2500 inherits \u2500\u2500 astropy/modeling/projections.py:Projection\n\u2514\u2500\u2500 contains-by \u2500\u2500 astropy/modeling/projections.py\n                   \u251c\u2500\u2500 contains-by \u2500\u2500 astropy/modeling\n                   \u2514\u2500\u2500 imports-by \u2500\u2500 astropy/modeling/models.py\n\nastropy/modeling/projections.py:Pix2Sky_SlantZenithalPerspective\n\u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/projections.py:Pix2Sky_SlantZenithalPerspective.mu\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/units/quantity.py:Quantity.any\n\u2502               \u2514\u2500\u2500 invokes \u2500\u2500 astropy/modeling/parameters.py:InputParameterError\n\u251c\u2500\u2500 inherits \u2500\u2500 astropy/modeling/projections.py:Pix2SkyProjection\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/projections.py:Pix2SkyProjection.__new__\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/projections.py:Pix2SkyProjection.input_units\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/projections.py:Pix2SkyProjection.return_units\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/projections.py:Pix2SkyProjection.evaluate\n\u2502               \u251c\u2500\u2500 contains \u2500\u2500 astropy/modeling/projections.py:Pix2SkyProjection.inverse\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/__init__.py:base_constants_version.set\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/table.py:PprintIncludeExclude.set\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/table/bst.py:Node.set\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/config/configuration.py:ConfigItem.set\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/io/fits/header.py:Header.set\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/decorators.py:deprecated_attribute.set\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/utils/state.py:ScienceState.set\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/core.py:_ModelMeta._handle_special_methods.__init__\n\u2502               \u251c\u2500\u2500 invokes \u2500\u2500 astropy/modeling/projections.py:Projection._update_prj\n\u2502               \u2514\u2500\u2500 inherits \u2500\u2500 astropy/modeling/projections.py:Projection\n\u251c\u2500\u2500 inherits \u2500\u2500 astropy/modeling/projections.py:Zenithal\n\u2502               \u2514\u2500\u2500 inherits \u2500\u2500 astropy/modeling/projections.py:Projection\n\u2514\u2500\u2500 contains-by \u2500\u2500 astropy/modeling/projections.py\n                   \u251c\u2500\u2500 contains-by \u2500\u2500 astropy/modeling\n                   \u2514\u2500\u2500 imports-by \u2500\u2500 astropy/modeling/models.py\n"}, {"role": "tool", "tool_call_id": "call_I2HdoJtDqbSz3a2nQwF8p9Mr", "name": "get_entity_contents", "content": "OBSERVATION:\n##Searching for entity `astropy/modeling/separable.py:separability_matrix`...\n### Search Result:\nFound function `astropy/modeling/separable.py:separability_matrix`.\nSource: Exact match found for entity name `astropy/modeling/separable.py:separability_matrix`.\n```\n 66 | def separability_matrix(transform):\n 67 |     \"\"\"\n 68 |     Compute the correlation between outputs and inputs.\n 69 | \n 70 |     Parameters\n 71 |     ----------\n 72 |     transform : `~astropy.modeling.core.Model`\n 73 |         A (compound) model.\n 74 | \n 75 |     Returns\n 76 |     -------\n 77 |     separable_matrix : ndarray\n 78 |         A boolean correlation matrix of shape (n_outputs, n_inputs).\n 79 |         Indicates the dependence of outputs on inputs. For completely\n 80 |         independent outputs, the diagonal elements are True and\n 81 |         off-diagonal elements are False.\n 82 | \n 83 |     Examples\n 84 |     --------\n 85 |     >>> from astropy.modeling.models import Shift, Scale, Rotation2D, Polynomial2D\n 86 |     >>> separability_matrix(Shift(1) & Shift(2) | Scale(1) & Scale(2))\n 87 |         array([[ True, False], [False,  True]]...)\n 88 |     >>> separability_matrix(Shift(1) & Shift(2) | Rotation2D(2))\n 89 |         array([[ True,  True], [ True,  True]]...)\n 90 |     >>> separability_matrix(Shift(1) & Shift(2) | Mapping([0, 1, 0, 1]) | \\\n 91 |         Polynomial2D(1) & Polynomial2D(2))\n 92 |         array([[ True,  True], [ True,  True]]...)\n 93 |     >>> separability_matrix(Shift(1) & Shift(2) | Mapping([0, 1, 0, 1]))\n 94 |         array([[ True, False], [False,  True], [ True, False], [False,  True]]...)\n 95 | \n 96 |     \"\"\"\n 97 |     if transform.n_inputs == 1 and transform.n_outputs > 1:\n 98 |         return np.ones((transform.n_outputs, transform.n_inputs),\n 99 |                        dtype=np.bool_)\n100 |     separable_matrix = _separable(transform)\n101 |     separable_matrix = np.where(separable_matrix != 0, True, False)\n102 |     return separable_matrix\n```\n\n\n##Searching for entity `astropy/modeling/functional_models.py:Linear1D`...\n### Search Result:\nFound class `astropy/modeling/functional_models.py:Linear1D`.\nSource: Exact match found for entity name `astropy/modeling/functional_models.py:Linear1D`.\n```\n1327 | class Linear1D(Fittable1DModel):\n1328 |     \"\"\"\n1329 |     One dimensional Line model.\n1330 | \n1331 |     Parameters\n1332 |     ----------\n1333 |     slope : float\n1334 |         Slope of the straight line\n1335 | \n1336 |     intercept : float\n1337 |         Intercept of the straight line\n1338 | \n1339 |     See Also\n1340 |     --------\n1341 |     Const1D\n1342 | \n1343 |     Notes\n1344 |     -----\n1345 |     Model formula:\n1346 | \n1347 |         .. math:: f(x) = a x + b\n1348 |     \"\"\"\n1349 |     slope = Parameter(default=1, description=\"Slope of the straight line\")\n1350 |     intercept = Parameter(default=0, description=\"Intercept of the straight line\")\n1351 |     linear = True\n1352 | \n1353 |     @staticmethod\n1354 |     def evaluate(x, slope, intercept):\n1355 |         \"\"\"One dimensional Line model function\"\"\"\n1356 | \n1357 |         return slope * x + intercept\n1358 | \n1359 |     @staticmethod\n1360 |     def fit_deriv(x, *params):\n1361 |         \"\"\"One dimensional Line model derivative with respect to parameters\"\"\"\n1362 | \n1363 |         d_slope = x\n1364 |         d_intercept = np.ones_like(x)\n1365 |         return [d_slope, d_intercept]\n1366 | \n1367 |     @property\n1368 |     def inverse(self):\n1369 |         new_slope = self.slope ** -1\n1370 |         new_intercept = -self.intercept / self.slope\n1371 |         return self.__class__(slope=new_slope, intercept=new_intercept)\n1372 | \n1373 |     @property\n1374 |     def input_units(self):\n1375 |         if self.intercept.unit is None and self.slope.unit is None:\n1376 |             return None\n1377 |         return {self.inputs[0]: self.intercept.unit / self.slope.unit}\n1378 | \n1379 |     def _parameter_units_for_data_units(self, inputs_unit, outputs_unit):\n1380 |         return {'intercept': outputs_unit[self.outputs[0]],\n1381 |                 'slope': outputs_unit[self.outputs[0]] / inputs_unit[self.inputs[0]]}\n```\n\n\n##Searching for entity `astropy/modeling/core.py:CompoundModel`...\n### Search Result:\nFound class `astropy/modeling/core.py:CompoundModel`.\nSource: Exact match found for entity name `astropy/modeling/core.py:CompoundModel`.\n```\n2894 | class CompoundModel(Model):\n2895 |     '''\n2896 |     Base class for compound models.\n2897 | \n2898 |     While it can be used directly, the recommended way\n2899 |     to combine models is through the model operators.\n2900 |     '''\n2901 | \n2902 |     def __init__(self, op, left, right, name=None):\n2903 |         self.__dict__['_param_names'] = None\n2904 |         self._n_submodels = None\n2905 |         self.op = op\n2906 |         self.left = left\n2907 |         self.right = right\n2908 |         self._bounding_box = None\n2909 |         self._user_bounding_box = None\n2910 |         self._leaflist = None\n2911 |         self._tdict = None\n2912 |         self._parameters = None\n2913 |         self._parameters_ = None\n2914 |         self._param_metrics = None\n2915 | \n2916 |         if op != 'fix_inputs' and len(left) != len(right):\n2917 |             raise ValueError(\n2918 |                 'Both operands must have equal values for n_models')\n2919 |         self._n_models = len(left)\n2920 | \n2921 |         if op != 'fix_inputs' and ((left.model_set_axis != right.model_set_axis)\n2922 |                                    or left.model_set_axis):  # not False and not 0\n2923 |             raise ValueError(\"model_set_axis must be False or 0 and consistent for operands\")\n2924 |         self._model_set_axis = left.model_set_axis\n2925 | \n2926 |         if op in ['+', '-', '*', '/', '**'] or op in SPECIAL_OPERATORS:\n2927 |             if (left.n_inputs != right.n_inputs) or \\\n2928 |                (left.n_outputs != right.n_outputs):\n2929 |                 raise ModelDefinitionError(\n2930 |                     'Both operands must match numbers of inputs and outputs')\n2931 |             self.n_inputs = left.n_inputs\n2932 |             self.n_outputs = left.n_outputs\n2933 |             self.inputs = left.inputs\n2934 |             self.outputs = left.outputs\n2935 |         elif op == '&':\n2936 |             self.n_inputs = left.n_inputs + right.n_inputs\n2937 |             self.n_outputs = left.n_outputs + right.n_outputs\n2938 |             self.inputs = combine_labels(left.inputs, right.inputs)\n2939 |             self.outputs = combine_labels(left.outputs, right.outputs)\n2940 |         elif op == '|':\n2941 |             if left.n_outputs != right.n_inputs:\n2942 |                 raise ModelDefinitionError(\n2943 |                     \"Unsupported operands for |: {0} (n_inputs={1}, \"\n2944 |                     \"n_outputs={2}) and {3} (n_inputs={4}, n_outputs={5}); \"\n2945 |                     \"n_outputs for the left-hand model must match n_inputs \"\n2946 |                     \"for the right-hand model.\".format(\n2947 |                         left.name, left.n_inputs, left.n_outputs, right.name,\n2948 |                         right.n_inputs, right.n_outputs))\n2949 | \n2950 |             self.n_inputs = left.n_inputs\n2951 |             self.n_outputs = right.n_outputs\n2952 |             self.inputs = left.inputs\n2953 |             self.outputs = right.outputs\n2954 |         elif op == 'fix_inputs':\n2955 |             if not isinstance(left, Model):\n2956 |                 raise ValueError('First argument to \"fix_inputs\" must be an instance of an astropy Model.')\n2957 |             if not isinstance(right, dict):\n2958 |                 raise ValueError('Expected a dictionary for second argument of \"fix_inputs\".')\n2959 | \n2960 |             # Dict keys must match either possible indices\n2961 |             # for model on left side, or names for inputs.\n2962 |             self.n_inputs = left.n_inputs - len(right)\n2963 |             # Assign directly to the private attribute (instead of using the setter)\n2964 |             # to avoid asserting the new number of outputs matches the old one.\n2965 |             self._outputs = left.outputs\n2966 |             self.n_outputs = left.n_outputs\n2967 |             newinputs = list(left.inputs)\n2968 |             keys = right.keys()\n2969 |             input_ind = []\n2970 |             for key in keys:\n2971 |                 if np.issubdtype(type(key), np.integer):\n2972 |                     if key >= left.n_inputs or key < 0:\n2973 |                         raise ValueError(\n2974 |                             'Substitution key integer value '\n2975 |                             'not among possible input choices.')\n2976 |                     if key in input_ind:\n2977 |                         raise ValueError(\"Duplicate specification of \"\n2978 |                                          \"same input (index/name).\")\n2979 |                     input_ind.append(key)\n2980 |                 elif isinstance(key, str):\n2981 |                     if key not in left.inputs:\n2982 |                         raise ValueError(\n2983 |                             'Substitution key string not among possible '\n2984 |                             'input choices.')\n2985 |                     # Check to see it doesn't match positional\n2986 |                     # specification.\n2987 |                     ind = left.inputs.index(key)\n2988 |                     if ind in input_ind:\n2989 |                         raise ValueError(\"Duplicate specification of \"\n2990 |                                          \"same input (index/name).\")\n2991 |                     input_ind.append(ind)\n2992 |             # Remove substituted inputs\n2993 |             input_ind.sort()\n2994 |             input_ind.reverse()\n2995 |             for ind in input_ind:\n2996 |                 del newinputs[ind]\n2997 |             self.inputs = tuple(newinputs)\n2998 |             # Now check to see if the input model has bounding_box defined.\n2999 |             # If so, remove the appropriate dimensions and set it for this\n3000 |             # instance.\n3001 |             try:\n3002 |                 self.bounding_box = \\\n3003 |                     self.left.bounding_box.fix_inputs(self, right)\n3004 |             except NotImplementedError:\n3005 |                 pass\n3006 | \n3007 |         else:\n3008 |             raise ModelDefinitionError('Illegal operator: ', self.op)\n3009 |         self.name = name\n3010 |         self._fittable = None\n3011 |         self.fit_deriv = None\n3012 |         self.col_fit_deriv = None\n3013 |         if op in ('|', '+', '-'):\n3014 |             self.linear = left.linear and right.linear\n3015 |         else:\n3016 |             self.linear = False\n3017 |         self.eqcons = []\n3018 |         self.ineqcons = []\n3019 |         self.n_left_params = len(self.left.parameters)\n3020 |         self._map_parameters()\n3021 | \n3022 |     def _get_left_inputs_from_args(self, args):\n3023 |         return args[:self.left.n_inputs]\n3024 | \n3025 |     def _get_right_inputs_from_args(self, args):\n3026 |         op = self.op\n3027 |         if op == '&':\n3028 |             # Args expected to look like (*left inputs, *right inputs, *left params, *right params)\n3029 |             return args[self.left.n_inputs: self.left.n_inputs + self.right.n_inputs]\n3030 |         elif op == '|' or  op == 'fix_inputs':\n3031 |             return None\n3032 |         else:\n3033 |             return args[:self.left.n_inputs]\n3034 | \n3035 |     def _get_left_params_from_args(self, args):\n3036 |         op = self.op\n3037 |         if op == '&':\n3038 |             # Args expected to look like (*left inputs, *right inputs, *left params, *right params)\n3039 |             n_inputs = self.left.n_inputs + self.right.n_inputs\n3040 |             return args[n_inputs: n_inputs + self.n_left_params]\n3041 |         else:\n3042 |             return args[self.left.n_inputs: self.left.n_inputs + self.n_left_params]\n3043 | \n3044 |     def _get_right_params_from_args(self, args):\n3045 |         op = self.op\n3046 |         if op == 'fix_inputs':\n3047 |             return None\n3048 |         if op == '&':\n3049 |             # Args expected to look like (*left inputs, *right inputs, *left params, *right params)\n3050 |             return args[self.left.n_inputs + self.right.n_inputs + self.n_left_params:]\n3051 |         else:\n3052 |             return args[self.left.n_inputs + self.n_left_params:]\n3053 | \n3054 |     def _get_kwarg_model_parameters_as_positional(self, args, kwargs):\n3055 |         # could do it with inserts but rebuilding seems like simpilist way\n3056 | \n3057 |         #TODO: Check if any param names are in kwargs maybe as an intersection of sets?\n3058 |         if self.op == \"&\":\n3059 |             new_args = list(args[:self.left.n_inputs + self.right.n_inputs])\n3060 |             args_pos = self.left.n_inputs + self.right.n_inputs\n3061 |         else:\n3062 |             new_args = list(args[:self.left.n_inputs])\n3063 |             args_pos = self.left.n_inputs\n3064 | \n3065 |         for param_name in self.param_names:\n3066 |             kw_value = kwargs.pop(param_name, None)\n3067 |             if kw_value is not None:\n3068 |                 value = kw_value\n3069 |             else:\n3070 |                 try:\n3071 |                     value = args[args_pos]\n3072 |                 except IndexError:\n3073 |                     raise IndexError(\"Missing parameter or input\")\n3074 | \n3075 |                 args_pos += 1\n3076 |             new_args.append(value)\n3077 | \n3078 |         return new_args, kwargs\n3079 | \n3080 |     def _apply_operators_to_value_lists(self, leftval, rightval, **kw):\n3081 |         op = self.op\n3082 |         if op == '+':\n3083 |             return binary_operation(operator.add, leftval, rightval)\n3084 |         elif op == '-':\n3085 |             return binary_operation(operator.sub, leftval, rightval)\n3086 |         elif op == '*':\n3087 |             return binary_operation(operator.mul, leftval, rightval)\n3088 |         elif op == '/':\n3089 |             return binary_operation(operator.truediv, leftval, rightval)\n3090 |         elif op == '**':\n3091 |             return binary_operation(operator.pow, leftval, rightval)\n3092 |         elif op == '&':\n3093 |             if not isinstance(leftval, tuple):\n3094 |                 leftval = (leftval,)\n3095 |             if not isinstance(rightval, tuple):\n3096 |                 rightval = (rightval,)\n3097 |             return leftval + rightval\n3098 |         elif op in SPECIAL_OPERATORS:\n3099 |             return binary_operation(SPECIAL_OPERATORS[op], leftval, rightval)\n3100 |         else:\n3101 |             raise ModelDefinitionError('Unrecognized operator {op}')\n3102 | \n3103 |     def evaluate(self, *args, **kw):\n3104 |         op = self.op\n3105 |         args, kw = self._get_kwarg_model_parameters_as_positional(args, kw)\n3106 |         left_inputs = self._get_left_inputs_from_args(args)\n3107 |         left_params = self._get_left_params_from_args(args)\n3108 | \n3109 |         if op == 'fix_inputs':\n3110 |             pos_index = dict(zip(self.left.inputs, range(self.left.n_inputs)))\n3111 |             fixed_inputs = {\n3112 |                 key if np.issubdtype(type(key), np.integer) else pos_index[key]: value\n3113 |                 for key, value in self.right.items()\n3114 |             }\n3115 |             left_inputs = [\n3116 |                 fixed_inputs[ind] if ind in fixed_inputs.keys() else inp\n3117 |                 for ind, inp in enumerate(left_inputs)\n3118 |             ]\n3119 | \n3120 |         leftval = self.left.evaluate(*itertools.chain(left_inputs, left_params))\n3121 | \n3122 |         if op == 'fix_inputs':\n3123 |             return leftval\n3124 | \n3125 |         right_inputs = self._get_right_inputs_from_args(args)\n3126 |         right_params = self._get_right_params_from_args(args)\n3127 | \n3128 |         if op == \"|\":\n3129 |             if isinstance(leftval, tuple):\n3130 |                 return self.right.evaluate(*itertools.chain(leftval, right_params))\n3131 |             else:\n3132 |                 return self.right.evaluate(leftval, *right_params)\n3133 |         else:\n3134 |             rightval = self.right.evaluate(*itertools.chain(right_inputs, right_params))\n3135 | \n3136 |         return self._apply_operators_to_value_lists(leftval, rightval, **kw)\n3137 | \n3138 |     @property\n3139 |     def n_submodels(self):\n3140 |         if self._leaflist is None:\n3141 |             self._make_leaflist()\n3142 |         return len(self._leaflist)\n3143 | \n3144 |     @property\n3145 |     def submodel_names(self):\n3146 |         \"\"\" Return the names of submodels in a ``CompoundModel``.\"\"\"\n3147 |         if self._leaflist is None:\n3148 |             self._make_leaflist()\n3149 |         names = [item.name for item in self._leaflist]\n3150 |         nonecount = 0\n3151 |         newnames = []\n3152 |         for item in names:\n3153 |             if item is None:\n3154 |                 newnames.append(f'None_{nonecount}')\n3155 |                 nonecount += 1\n3156 |             else:\n3157 |                 newnames.append(item)\n3158 |         return tuple(newnames)\n3159 | \n3160 |     def both_inverses_exist(self):\n3161 |         '''\n3162 |         if both members of this compound model have inverses return True\n3163 |         '''\n3164 |         warnings.warn(\n3165 |             \"CompoundModel.both_inverses_exist is deprecated. \"\n3166 |             \"Use has_inverse instead.\",\n3167 |             AstropyDeprecationWarning\n3168 |         )\n3169 | \n3170 |         try:\n3171 |             linv = self.left.inverse\n3172 |             rinv = self.right.inverse\n3173 |         except NotImplementedError:\n3174 |             return False\n3175 | \n3176 |         return True\n3177 | \n3178 |     def _pre_evaluate(self, *args, **kwargs):\n3179 |         \"\"\"\n3180 |         CompoundModel specific input setup that needs to occur prior to\n3181 |             model evaluation.\n3182 | \n3183 |         Note\n3184 |         ----\n3185 |             All of the _pre_evaluate for each component model will be\n3186 |             performed at the time that the individual model is evaluated.\n3187 |         \"\"\"\n3188 | \n3189 |         # If equivalencies are provided, necessary to map parameters and pass\n3190 |         # the leaflist as a keyword input for use by model evaluation so that\n3191 |         # the compound model input names can be matched to the model input\n3192 |         # names.\n3193 |         if 'equivalencies' in kwargs:\n3194 |             # Restructure to be useful for the individual model lookup\n3195 |             kwargs['inputs_map'] = [(value[0], (value[1], key)) for\n3196 |                                     key, value in self.inputs_map().items()]\n3197 | \n3198 |         # Setup actual model evaluation method\n3199 |         def evaluate(_inputs):\n3200 |             return self._evaluate(*_inputs, **kwargs)\n3201 | \n3202 |         return evaluate, args, None, kwargs\n3203 | \n3204 |     @property\n3205 |     def _argnames(self):\n3206 |         \"\"\"No inputs should be used to determine input_shape when handling compound models\"\"\"\n3207 |         return ()\n3208 | \n3209 |     def _post_evaluate(self, inputs, outputs, broadcasted_shapes, with_bbox, **kwargs):\n3210 |         \"\"\"\n3211 |         CompoundModel specific post evaluation processing of outputs\n3212 | \n3213 |         Note\n3214 |         ----\n3215 |             All of the _post_evaluate for each component model will be\n3216 |             performed at the time that the individual model is evaluated.\n3217 |         \"\"\"\n3218 |         if self.get_bounding_box(with_bbox) is not None and self.n_outputs == 1:\n3219 |             return outputs[0]\n3220 |         return outputs\n3221 | \n3222 |     def _evaluate(self, *args, **kw):\n3223 |         op = self.op\n3224 |         if op != 'fix_inputs':\n3225 |             if op != '&':\n3226 |                 leftval = self.left(*args, **kw)\n3227 |                 if op != '|':\n3228 |                     rightval = self.right(*args, **kw)\n3229 |                 else:\n3230 |                     rightval = None\n3231 | \n3232 |             else:\n3233 |                 leftval = self.left(*(args[:self.left.n_inputs]), **kw)\n3234 |                 rightval = self.right(*(args[self.left.n_inputs:]), **kw)\n3235 | \n3236 |             if op != \"|\":\n3237 |                 return self._apply_operators_to_value_lists(leftval, rightval, **kw)\n3238 | \n3239 |             elif op == '|':\n3240 |                 if isinstance(leftval, tuple):\n3241 |                     return self.right(*leftval, **kw)\n3242 |                 else:\n3243 |                     return self.right(leftval, **kw)\n3244 | \n3245 |         else:\n3246 |             subs = self.right\n3247 |             newargs = list(args)\n3248 |             subinds = []\n3249 |             subvals = []\n3250 |             for key in subs.keys():\n3251 |                 if np.issubdtype(type(key), np.integer):\n3252 |                     subinds.append(key)\n3253 |                 elif isinstance(key, str):\n3254 |                     ind = self.left.inputs.index(key)\n3255 |                     subinds.append(ind)\n3256 |                 subvals.append(subs[key])\n3257 |             # Turn inputs specified in kw into positional indices.\n3258 |             # Names for compound inputs do not propagate to sub models.\n3259 |             kwind = []\n3260 |             kwval = []\n3261 |             for kwkey in list(kw.keys()):\n3262 |                 if kwkey in self.inputs:\n3263 |                     ind = self.inputs.index(kwkey)\n3264 |                     if ind < len(args):\n3265 |                         raise ValueError(\"Keyword argument duplicates \"\n3266 |                                          \"positional value supplied.\")\n3267 |                     kwind.append(ind)\n3268 |                     kwval.append(kw[kwkey])\n3269 |                     del kw[kwkey]\n3270 |             # Build new argument list\n3271 |             # Append keyword specified args first\n3272 |             if kwind:\n3273 |                 kwargs = list(zip(kwind, kwval))\n3274 |                 kwargs.sort()\n3275 |                 kwindsorted, kwvalsorted = list(zip(*kwargs))\n3276 |                 newargs = newargs + list(kwvalsorted)\n3277 |             if subinds:\n3278 |                 subargs = list(zip(subinds, subvals))\n3279 |                 subargs.sort()\n3280 |                 # subindsorted, subvalsorted = list(zip(*subargs))\n3281 |                 # The substitutions must be inserted in order\n3282 |                 for ind, val in subargs:\n3283 |                     newargs.insert(ind, val)\n3284 |             return self.left(*newargs, **kw)\n3285 | \n3286 |     @property\n3287 |     def param_names(self):\n3288 |         \"\"\" An ordered list of parameter names.\"\"\"\n3289 |         return self._param_names\n3290 | \n3291 |     def _make_leaflist(self):\n3292 |         tdict = {}\n3293 |         leaflist = []\n3294 |         make_subtree_dict(self, '', tdict, leaflist)\n3295 |         self._leaflist = leaflist\n3296 |         self._tdict = tdict\n3297 | \n3298 |     def __getattr__(self, name):\n3299 |         \"\"\"\n3300 |         If someone accesses an attribute not already defined, map the\n3301 |         parameters, and then see if the requested attribute is one of\n3302 |         the parameters\n3303 |         \"\"\"\n3304 |         # The following test is needed to avoid infinite recursion\n3305 |         # caused by deepcopy. There may be other such cases discovered.\n3306 |         if name == '__setstate__':\n3307 |             raise AttributeError\n3308 |         if name in self._param_names:\n3309 |             return self.__dict__[name]\n3310 |         else:\n3311 |             raise AttributeError(f'Attribute \"{name}\" not found')\n3312 | \n3313 |     def __getitem__(self, index):\n3314 |         if self._leaflist is None:\n3315 |             self._make_leaflist()\n3316 |         leaflist = self._leaflist\n3317 |         tdict = self._tdict\n3318 |         if isinstance(index, slice):\n3319 |             if index.step:\n3320 |                 raise ValueError('Steps in slices not supported '\n3321 |                                  'for compound models')\n3322 |             if index.start is not None:\n3323 |                 if isinstance(index.start, str):\n3324 |                     start = self._str_index_to_int(index.start)\n3325 |                 else:\n3326 |                     start = index.start\n3327 |             else:\n3328 |                 start = 0\n3329 |             if index.stop is not None:\n3330 |                 if isinstance(index.stop, str):\n3331 |                     stop = self._str_index_to_int(index.stop)\n3332 |                 else:\n3333 |                     stop = index.stop - 1\n3334 |             else:\n3335 |                 stop = len(leaflist) - 1\n3336 |             if index.stop == 0:\n3337 |                 raise ValueError(\"Slice endpoint cannot be 0\")\n3338 |             if start < 0:\n3339 |                 start = len(leaflist) + start\n3340 |             if stop < 0:\n3341 |                 stop = len(leaflist) + stop\n3342 |             # now search for matching node:\n3343 |             if stop == start:  # only single value, get leaf instead in code below\n3344 |                 index = start\n3345 |             else:\n3346 |                 for key in tdict:\n3347 |                     node, leftind, rightind = tdict[key]\n3348 |                     if leftind == start and rightind == stop:\n3349 |                         return node\n3350 |                 raise IndexError(\"No appropriate subtree matches slice\")\n3351 |         if isinstance(index, type(0)):\n3352 |             return leaflist[index]\n3353 |         elif isinstance(index, type('')):\n3354 |             return leaflist[self._str_index_to_int(index)]\n3355 |         else:\n3356 |             raise TypeError('index must be integer, slice, or model name string')\n3357 | \n3358 |     def _str_index_to_int(self, str_index):\n3359 |         # Search through leaflist for item with that name\n3360 |         found = []\n3361 |         for nleaf, leaf in enumerate(self._leaflist):\n3362 |             if getattr(leaf, 'name', None) == str_index:\n3363 |                 found.append(nleaf)\n3364 |         if len(found) == 0:\n3365 |             raise IndexError(f\"No component with name '{str_index}' found\")\n3366 |         if len(found) > 1:\n3367 |             raise IndexError(\"Multiple components found using '{}' as name\\n\"\n3368 |                              \"at indices {}\".format(str_index, found))\n3369 |         return found[0]\n3370 | \n3371 |     @property\n3372 |     def n_inputs(self):\n3373 |         \"\"\" The number of inputs of a model.\"\"\"\n3374 |         return self._n_inputs\n3375 | \n3376 |     @n_inputs.setter\n3377 |     def n_inputs(self, value):\n3378 |         self._n_inputs = value\n3379 | \n3380 |     @property\n3381 |     def n_outputs(self):\n3382 |         \"\"\" The number of outputs of a model.\"\"\"\n3383 |         return self._n_outputs\n3384 | \n3385 |     @n_outputs.setter\n3386 |     def n_outputs(self, value):\n3387 |         self._n_outputs = value\n3388 | \n3389 |     @property\n3390 |     def eqcons(self):\n3391 |         return self._eqcons\n3392 | \n3393 |     @eqcons.setter\n3394 |     def eqcons(self, value):\n3395 |         self._eqcons = value\n3396 | \n3397 |     @property\n3398 |     def ineqcons(self):\n3399 |         return self._eqcons\n3400 | \n3401 |     @ineqcons.setter\n3402 |     def ineqcons(self, value):\n3403 |         self._eqcons = value\n3404 | \n3405 |     def traverse_postorder(self, include_operator=False):\n3406 |         \"\"\" Postorder traversal of the CompoundModel tree.\"\"\"\n3407 |         res = []\n3408 |         if isinstance(self.left, CompoundModel):\n3409 |             res = res + self.left.traverse_postorder(include_operator)\n3410 |         else:\n3411 |             res = res + [self.left]\n3412 |         if isinstance(self.right, CompoundModel):\n3413 |             res = res + self.right.traverse_postorder(include_operator)\n3414 |         else:\n3415 |             res = res + [self.right]\n3416 |         if include_operator:\n3417 |             res.append(self.op)\n3418 |         else:\n3419 |             res.append(self)\n3420 |         return res\n3421 | \n3422 |     def _format_expression(self, format_leaf=None):\n3423 |         leaf_idx = 0\n3424 |         operands = deque()\n3425 | \n3426 |         if format_leaf is None:\n3427 |             format_leaf = lambda i, l: f'[{i}]'\n3428 | \n3429 |         for node in self.traverse_postorder():\n3430 |             if not isinstance(node, CompoundModel):\n3431 |                 operands.append(format_leaf(leaf_idx, node))\n3432 |                 leaf_idx += 1\n3433 |                 continue\n3434 | \n3435 |             right = operands.pop()\n3436 |             left = operands.pop()\n3437 |             if node.op in OPERATOR_PRECEDENCE:\n3438 |                 oper_order = OPERATOR_PRECEDENCE[node.op]\n3439 | \n3440 |                 if isinstance(node, CompoundModel):\n3441 |                     if (isinstance(node.left, CompoundModel) and\n3442 |                             OPERATOR_PRECEDENCE[node.left.op] < oper_order):\n3443 |                         left = f'({left})'\n3444 |                     if (isinstance(node.right, CompoundModel) and\n3445 |                             OPERATOR_PRECEDENCE[node.right.op] < oper_order):\n3446 |                         right = f'({right})'\n3447 | \n3448 |                 operands.append(' '.join((left, node.op, right)))\n3449 |             else:\n3450 |                 left = f'(({left}),'\n3451 |                 right = f'({right}))'\n3452 |                 operands.append(' '.join((node.op[0], left, right)))\n3453 | \n3454 |         return ''.join(operands)\n3455 | \n3456 |     def _format_components(self):\n3457 |         if self._parameters_ is None:\n3458 |             self._map_parameters()\n3459 |         return '\\n\\n'.join('[{0}]: {1!r}'.format(idx, m)\n3460 |                            for idx, m in enumerate(self._leaflist))\n3461 | \n3462 |     def __str__(self):\n3463 |         expression = self._format_expression()\n3464 |         components = self._format_components()\n3465 |         keywords = [\n3466 |             ('Expression', expression),\n3467 |             ('Components', '\\n' + indent(components))\n3468 |         ]\n3469 |         return super()._format_str(keywords=keywords)\n3470 | \n3471 |     def rename(self, name):\n3472 |         self.name = name\n3473 |         return self\n3474 | \n3475 |     @property\n3476 |     def isleaf(self):\n3477 |         return False\n3478 | \n3479 |     @property\n3480 |     def inverse(self):\n3481 |         if self.op == '|':\n3482 |             return self.right.inverse | self.left.inverse\n3483 |         elif self.op == '&':\n3484 |             return self.left.inverse & self.right.inverse\n3485 |         else:\n3486 |             return NotImplemented\n3487 | \n3488 |     @property\n3489 |     def fittable(self):\n3490 |         \"\"\" Set the fittable attribute on a compound model.\"\"\"\n3491 |         if self._fittable is None:\n3492 |             if self._leaflist is None:\n3493 |                 self._map_parameters()\n3494 |             self._fittable = all(m.fittable for m in self._leaflist)\n3495 |         return self._fittable\n3496 | \n3497 |     __add__ = _model_oper('+')\n3498 |     __sub__ = _model_oper('-')\n3499 |     __mul__ = _model_oper('*')\n3500 |     __truediv__ = _model_oper('/')\n3501 |     __pow__ = _model_oper('**')\n3502 |     __or__ = _model_oper('|')\n3503 |     __and__ = _model_oper('&')\n3504 | \n3505 |     def _map_parameters(self):\n3506 |         \"\"\"\n3507 |         Map all the constituent model parameters to the compound object,\n3508 |         renaming as necessary by appending a suffix number.\n3509 | \n3510 |         This can be an expensive operation, particularly for a complex\n3511 |         expression tree.\n3512 | \n3513 |         All the corresponding parameter attributes are created that one\n3514 |         expects for the Model class.\n3515 | \n3516 |         The parameter objects that the attributes point to are the same\n3517 |         objects as in the constiutent models. Changes made to parameter\n3518 |         values to either are seen by both.\n3519 | \n3520 |         Prior to calling this, none of the associated attributes will\n3521 |         exist. This method must be called to make the model usable by\n3522 |         fitting engines.\n3523 | \n3524 |         If oldnames=True, then parameters are named as in the original\n3525 |         implementation of compound models.\n3526 |         \"\"\"\n3527 |         if self._parameters is not None:\n3528 |             # do nothing\n3529 |             return\n3530 |         if self._leaflist is None:\n3531 |             self._make_leaflist()\n3532 |         self._parameters_ = {}\n3533 |         param_map = {}\n3534 |         self._param_names = []\n3535 |         for lindex, leaf in enumerate(self._leaflist):\n3536 |             if not isinstance(leaf, dict):\n3537 |                 for param_name in leaf.param_names:\n3538 |                     param = getattr(leaf, param_name)\n3539 |                     new_param_name = f\"{param_name}_{lindex}\"\n3540 |                     self.__dict__[new_param_name] = param\n3541 |                     self._parameters_[new_param_name] = param\n3542 |                     self._param_names.append(new_param_name)\n3543 |                     param_map[new_param_name] = (lindex, param_name)\n3544 |         self._param_metrics = {}\n3545 |         self._param_map = param_map\n3546 |         self._param_map_inverse = dict((v, k) for k, v in param_map.items())\n3547 |         self._initialize_slices()\n3548 |         self._param_names = tuple(self._param_names)\n3549 | \n3550 |     def _initialize_slices(self):\n3551 |         param_metrics = self._param_metrics\n3552 |         total_size = 0\n3553 | \n3554 |         for name in self.param_names:\n3555 |             param = getattr(self, name)\n3556 |             value = param.value\n3557 |             param_size = np.size(value)\n3558 |             param_shape = np.shape(value)\n3559 |             param_slice = slice(total_size, total_size + param_size)\n3560 |             param_metrics[name] = {}\n3561 |             param_metrics[name]['slice'] = param_slice\n3562 |             param_metrics[name]['shape'] = param_shape\n3563 |             param_metrics[name]['size'] = param_size\n3564 |             total_size += param_size\n3565 |         self._parameters = np.empty(total_size, dtype=np.float64)\n3566 | \n3567 |     @staticmethod\n3568 |     def _recursive_lookup(branch, adict, key):\n3569 |         if isinstance(branch, CompoundModel):\n3570 |             return adict[key]\n3571 |         return branch, key\n3572 | \n3573 |     def inputs_map(self):\n3574 |         \"\"\"\n3575 |         Map the names of the inputs to this ExpressionTree to the inputs to the leaf models.\n3576 |         \"\"\"\n3577 |         inputs_map = {}\n3578 |         if not isinstance(self.op, str):  # If we don't have an operator the mapping is trivial\n3579 |             return {inp: (self, inp) for inp in self.inputs}\n3580 | \n3581 |         elif self.op == '|':\n3582 |             if isinstance(self.left, CompoundModel):\n3583 |                 l_inputs_map = self.left.inputs_map()\n3584 |             for inp in self.inputs:\n3585 |                 if isinstance(self.left, CompoundModel):\n3586 |                     inputs_map[inp] = l_inputs_map[inp]\n3587 |                 else:\n3588 |                     inputs_map[inp] = self.left, inp\n3589 |         elif self.op == '&':\n3590 |             if isinstance(self.left, CompoundModel):\n3591 |                 l_inputs_map = self.left.inputs_map()\n3592 |             if isinstance(self.right, CompoundModel):\n3593 |                 r_inputs_map = self.right.inputs_map()\n3594 |             for i, inp in enumerate(self.inputs):\n3595 |                 if i < len(self.left.inputs):  # Get from left\n3596 |                     if isinstance(self.left, CompoundModel):\n3597 |                         inputs_map[inp] = l_inputs_map[self.left.inputs[i]]\n3598 |                     else:\n3599 |                         inputs_map[inp] = self.left, self.left.inputs[i]\n3600 |                 else:  # Get from right\n3601 |                     if isinstance(self.right, CompoundModel):\n3602 |                         inputs_map[inp] = r_inputs_map[self.right.inputs[i - len(self.left.inputs)]]\n3603 |                     else:\n3604 |                         inputs_map[inp] = self.right, self.right.inputs[i - len(self.left.inputs)]\n3605 |         elif self.op == 'fix_inputs':\n3606 |             fixed_ind = list(self.right.keys())\n3607 |             ind = [list(self.left.inputs).index(i) if isinstance(i, str) else i for i in fixed_ind]\n3608 |             inp_ind = list(range(self.left.n_inputs))\n3609 |             for i in ind:\n3610 |                 inp_ind.remove(i)\n3611 |             for i in inp_ind:\n3612 |                 inputs_map[self.left.inputs[i]] = self.left, self.left.inputs[i]\n3613 |         else:\n3614 |             if isinstance(self.left, CompoundModel):\n3615 |                 l_inputs_map = self.left.inputs_map()\n3616 |             for inp in self.left.inputs:\n3617 |                 if isinstance(self.left, CompoundModel):\n3618 |                     inputs_map[inp] = l_inputs_map[inp]\n3619 |                 else:\n3620 |                     inputs_map[inp] = self.left, inp\n3621 |         return inputs_map\n3622 | \n3623 |     def _parameter_units_for_data_units(self, input_units, output_units):\n3624 |         if self._leaflist is None:\n3625 |             self._map_parameters()\n3626 |         units_for_data = {}\n3627 |         for imodel, model in enumerate(self._leaflist):\n3628 |             units_for_data_leaf = model._parameter_units_for_data_units(input_units, output_units)\n3629 |             for param_leaf in units_for_data_leaf:\n3630 |                 param = self._param_map_inverse[(imodel, param_leaf)]\n3631 |                 units_for_data[param] = units_for_data_leaf[param_leaf]\n3632 |         return units_for_data\n3633 | \n3634 |     @property\n3635 |     def input_units(self):\n3636 |         inputs_map = self.inputs_map()\n3637 |         input_units_dict = {key: inputs_map[key][0].input_units[orig_key]\n3638 |                             for key, (mod, orig_key) in inputs_map.items()\n3639 |                             if inputs_map[key][0].input_units is not None}\n3640 |         if input_units_dict:\n3641 |             return input_units_dict\n3642 |         return None\n3643 | \n3644 |     @property\n3645 |     def input_units_equivalencies(self):\n3646 |         inputs_map = self.inputs_map()\n3647 |         input_units_equivalencies_dict = {\n3648 |             key: inputs_map[key][0].input_units_equivalencies[orig_key]\n3649 |             for key, (mod, orig_key) in inputs_map.items()\n3650 |             if inputs_map[key][0].input_units_equivalencies is not None\n3651 |         }\n3652 |         if not input_units_equivalencies_dict:\n3653 |             return None\n3654 | \n3655 |         return input_units_equivalencies_dict\n3656 | \n3657 |     @property\n3658 |     def input_units_allow_dimensionless(self):\n3659 |         inputs_map = self.inputs_map()\n3660 |         return {key: inputs_map[key][0].input_units_allow_dimensionless[orig_key]\n3661 |                 for key, (mod, orig_key) in inputs_map.items()}\n3662 | \n3663 |     @property\n3664 |     def input_units_strict(self):\n3665 |         inputs_map = self.inputs_map()\n3666 |         return {key: inputs_map[key][0].input_units_strict[orig_key]\n3667 |                 for key, (mod, orig_key) in inputs_map.items()}\n3668 | \n3669 |     @property\n3670 |     def return_units(self):\n3671 |         outputs_map = self.outputs_map()\n3672 |         return {key: outputs_map[key][0].return_units[orig_key]\n3673 |                 for key, (mod, orig_key) in outputs_map.items()\n3674 |                 if outputs_map[key][0].return_units is not None}\n3675 | \n3676 |     def outputs_map(self):\n3677 |         \"\"\"\n3678 |         Map the names of the outputs to this ExpressionTree to the outputs to the leaf models.\n3679 |         \"\"\"\n3680 |         outputs_map = {}\n3681 |         if not isinstance(self.op, str):  # If we don't have an operator the mapping is trivial\n3682 |             return {out: (self, out) for out in self.outputs}\n3683 | \n3684 |         elif self.op == '|':\n3685 |             if isinstance(self.right, CompoundModel):\n3686 |                 r_outputs_map = self.right.outputs_map()\n3687 |             for out in self.outputs:\n3688 |                 if isinstance(self.right, CompoundModel):\n3689 |                     outputs_map[out] = r_outputs_map[out]\n3690 |                 else:\n3691 |                     outputs_map[out] = self.right, out\n3692 | \n3693 |         elif self.op == '&':\n3694 |             if isinstance(self.left, CompoundModel):\n3695 |                 l_outputs_map = self.left.outputs_map()\n3696 |             if isinstance(self.right, CompoundModel):\n3697 |                 r_outputs_map = self.right.outputs_map()\n3698 |             for i, out in enumerate(self.outputs):\n3699 |                 if i < len(self.left.outputs):  # Get from left\n3700 |                     if isinstance(self.left, CompoundModel):\n3701 |                         outputs_map[out] = l_outputs_map[self.left.outputs[i]]\n3702 |                     else:\n3703 |                         outputs_map[out] = self.left, self.left.outputs[i]\n3704 |                 else:  # Get from right\n3705 |                     if isinstance(self.right, CompoundModel):\n3706 |                         outputs_map[out] = r_outputs_map[self.right.outputs[i - len(self.left.outputs)]]\n3707 |                     else:\n3708 |                         outputs_map[out] = self.right, self.right.outputs[i - len(self.left.outputs)]\n3709 |         elif self.op == 'fix_inputs':\n3710 |             return self.left.outputs_map()\n3711 |         else:\n3712 |             if isinstance(self.left, CompoundModel):\n3713 |                 l_outputs_map = self.left.outputs_map()\n3714 |             for out in self.left.outputs:\n3715 |                 if isinstance(self.left, CompoundModel):\n3716 |                     outputs_map[out] = l_outputs_map()[out]\n3717 |                 else:\n3718 |                     outputs_map[out] = self.left, out\n3719 |         return outputs_map\n3720 | \n3721 |     @property\n3722 |     def has_user_bounding_box(self):\n3723 |         \"\"\"\n3724 |         A flag indicating whether or not a custom bounding_box has been\n3725 |         assigned to this model by a user, via assignment to\n3726 |         ``model.bounding_box``.\n3727 |         \"\"\"\n3728 | \n3729 |         return self._user_bounding_box is not None\n3730 | \n3731 |     def render(self, out=None, coords=None):\n3732 |         \"\"\"\n3733 |         Evaluate a model at fixed positions, respecting the ``bounding_box``.\n3734 | \n3735 |         The key difference relative to evaluating the model directly is that\n3736 |         this method is limited to a bounding box if the `Model.bounding_box`\n3737 |         attribute is set.\n3738 | \n3739 |         Parameters\n3740 |         ----------\n3741 |         out : `numpy.ndarray`, optional\n3742 |             An array that the evaluated model will be added to.  If this is not\n3743 |             given (or given as ``None``), a new array will be created.\n3744 |         coords : array-like, optional\n3745 |             An array to be used to translate from the model's input coordinates\n3746 |             to the ``out`` array. It should have the property that\n3747 |             ``self(coords)`` yields the same shape as ``out``.  If ``out`` is\n3748 |             not specified, ``coords`` will be used to determine the shape of\n3749 |             the returned array. If this is not provided (or None), the model\n3750 |             will be evaluated on a grid determined by `Model.bounding_box`.\n3751 | \n3752 |         Returns\n3753 |         -------\n3754 |         out : `numpy.ndarray`\n3755 |             The model added to ``out`` if  ``out`` is not ``None``, or else a\n3756 |             new array from evaluating the model over ``coords``.\n3757 |             If ``out`` and ``coords`` are both `None`, the returned array is\n3758 |             limited to the `Model.bounding_box` limits. If\n3759 |             `Model.bounding_box` is `None`, ``arr`` or ``coords`` must be\n3760 |             passed.\n3761 | \n3762 |         Raises\n3763 |         ------\n3764 |         ValueError\n3765 |             If ``coords`` are not given and the the `Model.bounding_box` of\n3766 |             this model is not set.\n3767 | \n3768 |         Examples\n3769 |         --------\n3770 |         :ref:`astropy:bounding-boxes`\n3771 |         \"\"\"\n3772 | \n3773 |         bbox = self.get_bounding_box()\n3774 | \n3775 |         ndim = self.n_inputs\n3776 | \n3777 |         if (coords is None) and (out is None) and (bbox is None):\n3778 |             raise ValueError('If no bounding_box is set, '\n3779 |                              'coords or out must be input.')\n3780 | \n3781 |         # for consistent indexing\n3782 |         if ndim == 1:\n3783 |             if coords is not None:\n3784 |                 coords = [coords]\n3785 |             if bbox is not None:\n3786 |                 bbox = [bbox]\n3787 | \n3788 |         if coords is not None:\n3789 |             coords = np.asanyarray(coords, dtype=float)\n3790 |             # Check dimensions match out and model\n3791 |             assert len(coords) == ndim\n3792 |             if out is not None:\n3793 |                 if coords[0].shape != out.shape:\n3794 |                     raise ValueError('inconsistent shape of the output.')\n3795 |             else:\n3796 |                 out = np.zeros(coords[0].shape)\n3797 | \n3798 |         if out is not None:\n3799 |             out = np.asanyarray(out)\n3800 |             if out.ndim != ndim:\n3801 |                 raise ValueError('the array and model must have the same '\n3802 |                                  'number of dimensions.')\n3803 | \n3804 |         if bbox is not None:\n3805 |             # Assures position is at center pixel, important when using\n3806 |             # add_array.\n3807 |             pd = np.array([(np.mean(bb), np.ceil((bb[1] - bb[0]) / 2))\n3808 |                            for bb in bbox]).astype(int).T\n3809 |             pos, delta = pd\n3810 | \n3811 |             if coords is not None:\n3812 |                 sub_shape = tuple(delta * 2 + 1)\n3813 |                 sub_coords = np.array([extract_array(c, sub_shape, pos)\n3814 |                                        for c in coords])\n3815 |             else:\n3816 |                 limits = [slice(p - d, p + d + 1, 1) for p, d in pd.T]\n3817 |                 sub_coords = np.mgrid[limits]\n3818 | \n3819 |             sub_coords = sub_coords[::-1]\n3820 | \n3821 |             if out is None:\n3822 |                 out = self(*sub_coords)\n3823 |             else:\n3824 |                 try:\n3825 |                     out = add_array(out, self(*sub_coords), pos)\n3826 |                 except ValueError:\n3827 |                     raise ValueError(\n3828 |                         'The `bounding_box` is larger than the input out in '\n3829 |                         'one or more dimensions. Set '\n3830 |                         '`model.bounding_box = None`.')\n3831 |         else:\n3832 |             if coords is None:\n3833 |                 im_shape = out.shape\n3834 |                 limits = [slice(i) for i in im_shape]\n3835 |                 coords = np.mgrid[limits]\n3836 | \n3837 |             coords = coords[::-1]\n3838 | \n3839 |             out += self(*coords)\n3840 | \n3841 |         return out\n3842 | \n3843 |     def replace_submodel(self, name, model):\n3844 |         \"\"\"\n3845 |         Construct a new `~astropy.modeling.CompoundModel` instance from an\n3846 |         existing CompoundModel, replacing the named submodel with a new model.\n3847 | \n3848 |         In order to ensure that inverses and names are kept/reconstructed, it's\n3849 |         necessary to rebuild the CompoundModel from the replaced node all the\n3850 |         way back to the base. The original CompoundModel is left untouched.\n3851 | \n3852 |         Parameters\n3853 |         ----------\n3854 |         name : str\n3855 |             name of submodel to be replaced\n3856 |         model : `~astropy.modeling.Model`\n3857 |             replacement model\n3858 |         \"\"\"\n3859 |         submodels = [m for m in self.traverse_postorder()\n3860 |                      if getattr(m, 'name', None) == name]\n3861 |         if submodels:\n3862 |             if len(submodels) > 1:\n3863 |                 raise ValueError(f\"More than one submodel named {name}\")\n3864 | \n3865 |             old_model = submodels.pop()\n3866 |             if len(old_model) != len(model):\n3867 |                 raise ValueError(\"New and old models must have equal values \"\n3868 |                                  \"for n_models\")\n3869 | \n3870 |             # Do this check first in order to raise a more helpful Exception,\n3871 |             # although it would fail trying to construct the new CompoundModel\n3872 |             if (old_model.n_inputs != model.n_inputs or\n3873 |                         old_model.n_outputs != model.n_outputs):\n3874 |                 raise ValueError(\"New model must match numbers of inputs and \"\n3875 |                                  \"outputs of existing model\")\n3876 | \n3877 |             tree = _get_submodel_path(self, name)\n3878 |             while tree:\n3879 |                 branch = self.copy()\n3880 |                 for node in tree[:-1]:\n3881 |                     branch = getattr(branch, node)\n3882 |                 setattr(branch, tree[-1], model)\n3883 |                 model = CompoundModel(branch.op, branch.left, branch.right,\n3884 |                                       name=branch.name)\n3885 |                 tree = tree[:-1]\n3886 |             return model\n3887 | \n3888 |         else:\n3889 |             raise ValueError(f\"No submodels found named {name}\")\n3890 | \n3891 |     def _set_sub_models_and_parameter_units(self, left, right):\n3892 |         \"\"\"\n3893 |         Provides a work-around to properly set the sub models and respective\n3894 |         parameters's units/values when using ``without_units_for_data``\n3895 |         or ``without_units_for_data`` methods.\n3896 |         \"\"\"\n3897 |         model = CompoundModel(self.op, left, right)\n3898 | \n3899 |         self.left = left\n3900 |         self.right = right\n3901 | \n3902 |         for name in model.param_names:\n3903 |             model_parameter = getattr(model, name)\n3904 |             parameter = getattr(self, name)\n3905 | \n3906 |             parameter.value = model_parameter.value\n3907 |             parameter._set_unit(model_parameter.unit, force=True)\n3908 | \n3909 |     def without_units_for_data(self, **kwargs):\n3910 |         \"\"\"\n3911 |         See `~astropy.modeling.Model.without_units_for_data` for overview\n3912 |         of this method.\n3913 | \n3914 |         Notes\n3915 |         -----\n3916 |         This modifies the behavior of the base method to account for the\n3917 |         case where the sub-models of a compound model have different output\n3918 |         units. This is only valid for compound * and / compound models as\n3919 |         in that case it is reasonable to mix the output units. It does this\n3920 |         by modifying the output units of each sub model by using the output\n3921 |         units of the other sub model so that we can apply the original function\n3922 |         and get the desired result.\n3923 | \n3924 |         Additional data has to be output in the mixed output unit case\n3925 |         so that the units can be properly rebuilt by\n3926 |         `~astropy.modeling.CompoundModel.with_units_from_data`.\n3927 | \n3928 |         Outside the mixed output units, this method is identical to the\n3929 |         base method.\n3930 |         \"\"\"\n3931 |         if self.op in ['*', '/']:\n3932 |             model = self.copy()\n3933 |             inputs = {inp: kwargs[inp] for inp in self.inputs}\n3934 | \n3935 |             left_units = self.left.output_units(**kwargs)\n3936 |             right_units = self.right.output_units(**kwargs)\n3937 | \n3938 |             if self.op == '*':\n3939 |                 left_kwargs = {out: kwargs[out] / right_units[out]\n3940 |                                for out in self.left.outputs if kwargs[out] is not None}\n3941 |                 right_kwargs = {out: kwargs[out] / left_units[out]\n3942 |                                 for out in self.right.outputs if kwargs[out] is not None}\n3943 |             else:\n3944 |                 left_kwargs = {out: kwargs[out] * right_units[out]\n3945 |                                for out in self.left.outputs if kwargs[out] is not None}\n3946 |                 right_kwargs = {out: 1 / kwargs[out] * left_units[out]\n3947 |                                 for out in self.right.outputs if kwargs[out] is not None}\n3948 | \n3949 |             left_kwargs.update(inputs.copy())\n3950 |             right_kwargs.update(inputs.copy())\n3951 | \n3952 |             left = self.left.without_units_for_data(**left_kwargs)\n3953 |             if isinstance(left, tuple):\n3954 |                 left_kwargs['_left_kwargs'] = left[1]\n3955 |                 left_kwargs['_right_kwargs'] = left[2]\n3956 |                 left = left[0]\n3957 | \n3958 |             right = self.right.without_units_for_data(**right_kwargs)\n3959 |             if isinstance(right, tuple):\n3960 |                 right_kwargs['_left_kwargs'] = right[1]\n3961 |                 right_kwargs['_right_kwargs'] = right[2]\n3962 |                 right = right[0]\n3963 | \n3964 |             model._set_sub_models_and_parameter_units(left, right)\n3965 | \n3966 |             return model, left_kwargs, right_kwargs\n3967 |         else:\n3968 |             return super().without_units_for_data(**kwargs)\n3969 | \n3970 |     def with_units_from_data(self, **kwargs):\n3971 |         \"\"\"\n3972 |         See `~astropy.modeling.Model.with_units_from_data` for overview\n3973 |         of this method.\n3974 | \n3975 |         Notes\n3976 |         -----\n3977 |         This modifies the behavior of the base method to account for the\n3978 |         case where the sub-models of a compound model have different output\n3979 |         units. This is only valid for compound * and / compound models as\n3980 |         in that case it is reasonable to mix the output units. In order to\n3981 |         do this it requires some additional information output by\n3982 |         `~astropy.modeling.CompoundModel.without_units_for_data` passed as\n3983 |         keyword arguments under the keywords ``_left_kwargs`` and ``_right_kwargs``.\n3984 | \n3985 |         Outside the mixed output units, this method is identical to the\n3986 |         base method.\n3987 |         \"\"\"\n3988 | \n3989 |         if self.op in ['*', '/']:\n3990 |             left_kwargs = kwargs.pop('_left_kwargs')\n3991 |             right_kwargs = kwargs.pop('_right_kwargs')\n3992 | \n3993 |             left = self.left.with_units_from_data(**left_kwargs)\n3994 |             right = self.right.with_units_from_data(**right_kwargs)\n3995 | \n3996 |             model = self.copy()\n3997 |             model._set_sub_models_and_parameter_units(left, right)\n3998 | \n3999 |             return model\n4000 |         else:\n4001 |             return super().with_units_from_data(**kwargs)\n```\n\n\n##Searching for entity `astropy/modeling/projections.py:Pix2Sky_ZenithalPerspective`...\n### Search Result:\nFound class `astropy/modeling/projections.py:Pix2Sky_ZenithalPerspective`.\nSource: Exact match found for entity name `astropy/modeling/projections.py:Pix2Sky_ZenithalPerspective`.\n```\n269 | class Pix2Sky_ZenithalPerspective(Pix2SkyProjection, Zenithal):\n270 |     r\"\"\"\n271 |     Zenithal perspective projection - pixel to sky.\n272 | \n273 |     Corresponds to the ``AZP`` projection in FITS WCS.\n274 | \n275 |     .. math::\n276 |         \\phi &= \\arg(-y \\cos \\gamma, x) \\\\\n277 |         \\theta &= \\left\\{\\genfrac{}{}{0pt}{}{\\psi - \\omega}{\\psi + \\omega + 180^{\\circ}}\\right.\n278 | \n279 |     where:\n280 | \n281 |     .. math::\n282 |         \\psi &= \\arg(\\rho, 1) \\\\\n283 |         \\omega &= \\sin^{-1}\\left(\\frac{\\rho \\mu}{\\sqrt{\\rho^2 + 1}}\\right) \\\\\n284 |         \\rho &= \\frac{R}{\\frac{180^{\\circ}}{\\pi}(\\mu + 1) + y \\sin \\gamma} \\\\\n285 |         R &= \\sqrt{x^2 + y^2 \\cos^2 \\gamma}\n286 | \n287 |     Parameters\n288 |     ----------\n289 |     mu : float\n290 |         Distance from point of projection to center of sphere\n291 |         in spherical radii, \u03bc.  Default is 0.\n292 | \n293 |     gamma : float\n294 |         Look angle \u03b3 in degrees.  Default is 0\u00b0.\n295 | \n296 |     \"\"\"\n297 |     mu = _ParameterDS(\n298 |         default=0.0, description=\"Distance from point of projection to center of sphere\"\n299 |     )\n300 |     gamma = _ParameterDS(default=0.0, getter=_to_orig_unit, setter=_to_radian,\n301 |                          description=\"Look angle \u03b3 in degrees (Default = 0\u00b0)\")\n302 | \n303 |     @mu.validator\n304 |     def mu(self, value):\n305 |         if np.any(np.equal(value, -1.0)):\n306 |             raise InputParameterError(\n307 |                 \"Zenithal perspective projection is not defined for mu = -1\")\n```\n\n\n##Searching for entity `astropy/modeling/projections.py:Pix2Sky_SlantZenithalPerspective`...\n### Search Result:\nFound class `astropy/modeling/projections.py:Pix2Sky_SlantZenithalPerspective`.\nSource: Exact match found for entity name `astropy/modeling/projections.py:Pix2Sky_SlantZenithalPerspective`.\n```\n349 | class Pix2Sky_SlantZenithalPerspective(Pix2SkyProjection, Zenithal):\n350 |     r\"\"\"\n351 |     Slant zenithal perspective projection - pixel to sky.\n352 | \n353 |     Corresponds to the ``SZP`` projection in FITS WCS.\n354 | \n355 |     Parameters\n356 |     ----------\n357 |     mu : float\n358 |         Distance from point of projection to center of sphere\n359 |         in spherical radii, \u03bc.  Default is 0.\n360 | \n361 |     phi0 : float\n362 |         The longitude \u03c6\u2080 of the reference point, in degrees.  Default\n363 |         is 0\u00b0.\n364 | \n365 |     theta0 : float\n366 |         The latitude \u03b8\u2080 of the reference point, in degrees.  Default\n367 |         is 90\u00b0.\n368 | \n369 |     \"\"\"\n370 |     mu = _ParameterDS(\n371 |         default=0.0,\n372 |         description=\"Distance from point of projection to center of sphere\"\n373 |     )\n374 |     phi0 = _ParameterDS(\n375 |         default=0.0, getter=_to_orig_unit, setter=_to_radian,\n376 |         description=\"The longitude \u03c6\u2080 of the reference point in degrees (Default=0\u00b0)\"\n377 |     )\n378 |     theta0 = _ParameterDS(\n379 |         default=90.0, getter=_to_orig_unit, setter=_to_radian,\n380 |         description=\"The latitude \u03b8\u2080 of the reference point, in degrees (Default=0\u00b0)\"\n381 |     )\n382 | \n383 |     @mu.validator\n384 |     def mu(self, value):\n385 |         if np.any(np.equal(value, -1.0)):\n386 |             raise InputParameterError(\n387 |                 \"Zenithal perspective projection is not defined for mu = -1\")\n```\n"}, {"content": "After thoroughly analyzing the codebase, here are the updated and verified locations that contain all necessary information to address the issue involving the `separability_matrix` in nested `CompoundModels`, alongside additional references that could be relevant:\n\n1. **Function Definitions**\n   - `astropy/modeling/separable.py:separability_matrix` - Contains the main logic for computing the separability matrix.\n   - `astropy/modeling/functional_models.py:Linear1D` - Represents the linear model which is essential for the bug because its interaction defines the behavior of the compound model when nested.\n   - `astropy/modeling/core.py:CompoundModel` - Core class representing compound models that requires modification to fix the separability logic.\n\n2. **Model Definitions**\n   - `astropy/modeling/projections.py:Pix2Sky_ZenithalPerspective` - A projection model that may illustrate the failure or boundaries of functionality expected.\n   - `astropy/modeling/projections.py:Pix2Sky_SlantZenithalPerspective` - Another projection model that could impact the separability criteria under certain conditions.\n\n3. **Dependency and Invocation**\n   - Dependencies invoked by these components, like `_separable`, `evaluate`, and `inputs_map` methods within `CompoundModel`, indicate where the evaluation logic interacts with model separability.\n   - Each of these components interacts heavily with the `Evaluate method` for the models indicating where bugs might propagate or be traced.\n\n4. **Additional Notes on Impact**\n   - The `CompoundModel` class contains multiple methods that handle evaluations, which can create unexpected separability outcomes when nested improperly.\n   - References to methods that are inherited from the base `Model` class might also provide valuable insights into the underlying problem.\n\nHere's a properly formatted list of all the confirmed relevant locations:\n\n```\nastropy/modeling/separable.py:separability_matrix\nastropy/modeling/functional_models.py:Linear1D\nastropy/modeling/core.py:CompoundModel\nastropy/modeling/projections.py:Pix2Sky_ZenithalPerspective\nastropy/modeling/projections.py:Pix2Sky_SlantZenithalPerspective\nastropy/modeling/core.py:CompoundModel.evaluate\nastropy/modeling/core.py:CompoundModel.inputs_map\nastropy/modeling/core.py:CompoundModel._apply_operators_to_value_lists\nastropy/modeling/core.py:CompoundModel.n_inputs\nastropy/modeling/core.py:CompoundModel.n_outputs\n```\n\nThese locations are crucial to resolving the reported issue regarding the `separability_matrix` output for nested `CompoundModels`, and I will conclude the interaction now. \n\n``` \nastropy/modeling/separable.py:separability_matrix\nastropy/modeling/functional_models.py:Linear1D\nastropy/modeling/core.py:CompoundModel\nastropy/modeling/projections.py:Pix2Sky_ZenithalPerspective\nastropy/modeling/projections.py:Pix2Sky_SlantZenithalPerspective\nastropy/modeling/core.py:CompoundModel.evaluate\nastropy/modeling/core.py:CompoundModel.inputs_map\nastropy/modeling/core.py:CompoundModel._apply_operators_to_value_lists\nastropy/modeling/core.py:CompoundModel.n_inputs\nastropy/modeling/core.py:CompoundModel.n_outputs\n```\n\nNow, I will call the finish function.", "role": "assistant", "tool_calls": [{"function": {"arguments": "{}", "name": "finish"}, "id": "call_MrbhdP9WHmJiWy1dvwg3AlYL", "type": "function"}], "function_call": null}], "tools": [{"type": "function", "function": {"name": "finish", "description": "Finish the interaction when the task is complete OR if the assistant cannot proceed further with the task."}}, {"type": "function", "function": {"name": "search_code_snippets", "description": "Searches the codebase to retrieve relevant code snippets based on given queries(terms or line numbers).\n** Note:\n- Either `search_terms` or `line_nums` must be provided to perform a search.\n- If `search_terms` are provided, it searches for code snippets based on each term:\n- If `line_nums` is provided, it searches for code snippets around the specified lines within the file defined by `file_path_or_pattern`.\n\n** Example Usage:\n# Search for code content contain keyword `order`, `bill`\nsearch_code_snippets(search_terms=[\"order\", \"bill\"])\n\n# Search for a class\nsearch_code_snippets(search_terms=[\"MyClass\"])\n\n# Search for context around specific lines (10 and 15) within a file\nsearch_code_snippets(line_nums=[10, 15], file_path_or_pattern='src/example.py')\n", "parameters": {"type": "object", "properties": {"search_terms": {"type": "array", "items": {"type": "string"}, "description": "A list of names, keywords, or code snippets to search for within the codebase. This can include potential function names, class names, or general code fragments. Either `search_terms` or `line_nums` must be provided to perform a search."}, "line_nums": {"type": "array", "items": {"type": "integer"}, "description": "Specific line numbers to locate code snippets within a specified file. Must be used alongside a valid `file_path_or_pattern`. Either `line_nums` or `search_terms` must be provided to perform a search."}, "file_path_or_pattern": {"type": "string", "description": "A glob pattern or specific file path used to filter search results to particular files or directories. Defaults to \"**/*.py\", meaning all Python files are searched by default. If `line_nums` are provided, this must specify a specific file path.", "default": "**/*.py"}}, "required": []}}}, {"type": "function", "function": {"name": "get_entity_contents", "description": "\nSearches the codebase to retrieve the complete implementations of specified entities based on the provided entity names. \nThe tool can handle specific entity queries such as function names, class names, or file paths.\n\n**Usage Example:**\n# Search for a specific function implementation\nget_entity_contents(['src/my_file.py:MyClass.func_name'])\n\n# Search for a file's complete content\nget_entity_contents(['src/my_file.py'])\n\n**Entity Name Format:**\n- To specify a function or class, use the format: `file_path:QualifiedName`\n  (e.g., 'src/helpers/math_helpers.py:MathUtils.calculate_sum').\n- To search for a file's content, use only the file path (e.g., 'src/my_file.py').\n", "parameters": {"type": "object", "properties": {"entity_names": {"type": "array", "items": {"type": "string"}, "description": "A list of entity names to query. Each entity name can represent a function, class, or file. For functions or classes, the format should be 'file_path:QualifiedName' (e.g., 'src/helpers/math_helpers.py:MathUtils.calculate_sum'). For files, use just the file path (e.g., 'src/my_file.py')."}}, "required": ["entity_names"]}}}, {"type": "function", "function": {"name": "explore_tree_structure", "description": "\nA unified tool that traverses a pre-built code graph to retrieve dependency structure around specified entities, \nwith options to explore upstream or downstream, and control traversal depth and filters for entity and dependency types.\n\nExample Usage:\n1. Exploring Downstream Dependencies:\n    ```\n    explore_tree_structure(\n        start_entities=['src/module_a.py:ClassA'],\n        direction='downstream',\n        traversal_depth=2,\n        dependency_type_filter=['invokes', 'imports']\n    )\n    ```\n2. Exploring the repository structure from the root directory (/) up to two levels deep:\n    ```\n    explore_tree_structure(\n      start_entities=['/'],\n      traversal_depth=2,\n      dependency_type_filter=['contains']\n    )\n    ```\n3. Generate Class Diagrams:\n    ```\n    explore_tree_structure(\n        start_entities=selected_entity_ids,\n        direction='both',\n        traverse_depth=-1,\n        dependency_type_filter=['inherits']\n    )\n    ```\n", "parameters": {"type": "object", "properties": {"start_entities": {"description": "List of entities (e.g., class, function, file, or directory paths) to begin the search from.\nEntities representing classes or functions must be formatted as \"file_path:QualifiedName\" (e.g., `interface/C.py:C.method_a.inner_func`).\nFor files or directories, provide only the file or directory path (e.g., `src/module_a.py` or `src/`).", "type": "array", "items": {"type": "string"}}, "direction": {"description": "Direction of traversal in the code graph; allowed options are: `upstream`, `downstream`, `both`.\n- 'upstream': Traversal to explore dependencies that the specified entities rely on (how they depend on others).\n- 'downstream': Traversal to explore the effects or interactions of the specified entities on others (how others depend on them).\n- 'both': Traversal on both direction.", "type": "string", "enum": ["upstream", "downstream", "both"], "default": "downstream"}, "traversal_depth": {"description": "Maximum depth of traversal. A value of -1 indicates unlimited depth (subject to a maximum limit).Must be either `-1` or a non-negative integer (\u2265 0).", "type": "integer", "default": 2}, "entity_type_filter": {"description": "List of entity types (e.g., 'class', 'function', 'file', 'directory') to include in the traversal. If None, all entity types are included.", "type": ["array", "null"], "items": {"type": "string"}, "default": null}, "dependency_type_filter": {"description": "List of dependency types (e.g., 'contains', 'imports', 'invokes', 'inherits') to include in the traversal. If None, all dependency types are included.", "type": ["array", "null"], "items": {"type": "string"}, "default": null}}, "required": ["start_entities"]}}}], "usage": {"prompt_tokens": 93923, "completion_tokens": 1126}, "time": 30.071966886520386}]}}
